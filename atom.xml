<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LoongFly的博客</title>
  <icon>https://www.gravatar.com/avatar/99179de3d0b7799ea71b65793bf56687</icon>
  <subtitle>前端攻城狮一枚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://longfeihouhouhou.github.io/"/>
  <updated>2018-03-21T13:34:43.117Z</updated>
  <id>http://longfeihouhouhou.github.io/</id>
  
  <author>
    <name>LoongFly</name>
    <email>695409705@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS常用的数组排序和去重</title>
    <link href="http://longfeihouhouhou.github.io/JS%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8E%BB%E9%87%8D.md/"/>
    <id>http://longfeihouhouhou.github.io/JS常用的数组排序和去重.md/</id>
    <published>2018-03-18T13:21:26.000Z</published>
    <updated>2018-03-21T13:34:43.117Z</updated>
    
    <content type="html"><![CDATA[<p>##排序</p><blockquote><p>冒泡排序<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span><span class="params">(ary)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; ary.length<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ary[j] &gt; ary[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">var</span> tem = ary[j];</span><br><span class="line">                ary[j] = ary[j+<span class="number">1</span>];</span><br><span class="line">                ary[j+<span class="number">1</span>] = tem;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>  冒泡排序的思想：首先在外侧顶一个flag为false，在外侧for i 循环原数组，在i循环内部 for j循环原数组，如果ary[j]&gt;ary[j+1]调换两者的位置，将flag置位true。然后在内部循环完成后判断flag情况，如果为true，就置位false，否则就break。为什么break？冒泡就是相邻两个比，如果大了就换位置，但是需要比多少轮呢？数组length-1轮，立flag就是为了优化性能的，当比较完一轮后发现没有需要换位置的就是说嘛已经排好了，就该break了，否则就该给flag置位false继续；</p><blockquote><p>快速排序<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">quickSort</span>(ary)&#123;</span><br><span class="line">    <span class="keyword">if</span> (ary.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pointIndex = <span class="type">Math</span>.floor(ary.length / <span class="number">2</span>),</span><br><span class="line">        pointVal = ary.splice(pointIndex, <span class="number">1</span>)[<span class="number">0</span>],</span><br><span class="line">        <span class="keyword">left</span> = [],</span><br><span class="line">        <span class="keyword">right</span> = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = ary[i];</span><br><span class="line">        cur &lt; pointVal ? <span class="keyword">left</span>.push(cur) : <span class="keyword">right</span>.push(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSort</span>(<span class="keyword">left</span>).concat(pointVal, <span class="built_in">quickSort</span>(<span class="keyword">right</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>快速排序思想：快速排序是一个递归，递归终止的条件就是ary的length&lt;=1的时候就return ary；否则就定义数组的中间值索引、中间值、left、right数组，接下来在for i循环中遍历原数组，在遍历中比较当前项和数组的中间值的大小，如果小则push进left，否则push进right，在函数结尾，for loop外侧return quickSort(left).concat(pointVal, quickSort(right));</p><blockquote><p>插入排序<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span></span>(ary)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Ary</span> = [];</span><br><span class="line">    <span class="keyword">new</span><span class="type">Ary</span>.push(ary[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> cur = ary[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="keyword">new</span><span class="type">Ary</span>.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="keyword">new</span><span class="type">Ary</span>[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">if</span> (j === <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Ary</span>.unshift(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">new</span><span class="type">Ary</span>.splice(j + <span class="number">1</span>, <span class="number">0</span> ,cur);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Ary</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>插入排序的思想：搞一个新的数组，现将原数组的第一项插入其中，然后从第二项for i循环原数组，在这个循环中for j倒序循环新的数组，用原数组的当前项ary[i]和新数组的当前项ary[j]相比，ary[i] &lt; ary[j] 如果条件成立，则和新数组的倒数下一项比，所以j–，但是要考虑一种情况，就是说数组中之后一项的时候，这个时候就应该把这ary[i]插入到数组的最前面；否则，即ary[i] &gt;= ary[j]的情况，把他塞到ary[j]的下一项去，同时应该break，为什么break，因为这个新数组是从大到小排的，比到这里就可以了，因为ary[j]前面的都比他小，没必要在比较了。</p><p>##数组去重</p><blockquote><p>对象法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params">pro</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = &#123;&#125;;<span class="number">0</span></span><br><span class="line">            pro.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> arr = <span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">var</span> cur = arr[i];</span><br><span class="line">                    <span class="keyword">if</span> (obj[cur] == cur) &#123;</span><br><span class="line">                        arr[i] = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">                        arr.length--;</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        obj[cur] = cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(<span class="built_in">Array</span>.prototype);</span><br></pre></td></tr></table></figure></p></blockquote><p>对象法去重：首先定义一个对象，接下来for i loop，在循环中判断cur = ary[i]，ary[i] == obj[cur]，满足条件说明已经重复了，接下来让ary[i] = ary[ary.length -1]，ary.length–;数组长度变小了，i–；如果不满足说明就是没重复，那就给对象增加obj[cur] = cur;</p><blockquote><p>双for循环<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique1 = function () &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> nIndex = <span class="number">0</span>; nIndex &lt; <span class="keyword">this</span>.length; nIndex ++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> i = nIndex + <span class="number">1</span>;i &lt; <span class="keyword">this</span>.length;) &#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>[nIndex] == <span class="keyword">this</span>[i]) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.splice(i, <span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p></blockquote><p>双for循环就是，在外侧for i loop中，for j loop，但是j不是从0开始，是从 i + 1开始，就是说从这一项的后一项开始往后找，如果找到ary[i] == ary[j]就是splice第i项，否则的话，i++进行下一项<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params">pro</span>)</span>&#123;</span><br><span class="line">    pro.thComma = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> reg = <span class="regexp">/\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+$)/g</span>;</span><br><span class="line">        <span class="keyword">return</span> str.replace(<span class="regexp">/^(\d+)((\.\d+)?)$/</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s, s1, s2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s1.replace(reg, <span class="string">"$&amp;,"</span>) + s2;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">String</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'12345687.12445'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.thComma());</span><br><span class="line"><span class="keyword">var</span> ary1 = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##排序&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;冒泡排序&lt;br&gt;&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6(3) 字符串扩展</title>
    <link href="http://longfeihouhouhou.github.io/es6-3-StringExt.md/"/>
    <id>http://longfeihouhouhou.github.io/es6-3-StringExt.md/</id>
    <published>2017-10-01T13:33:16.000Z</published>
    <updated>2018-03-20T02:51:56.160Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串数据类型新增了很多功能，其中对Unicode进行了大幅度的增强，新增了若干方法，同时引进了模板字符串，本节只讨论模板字符串的部分功能。</p><h2 id="字符的Unicode表示法增强。"><a href="#字符的Unicode表示法增强。" class="headerlink" title="字符的Unicode表示法增强。"></a>字符的Unicode表示法增强。</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javascript允许采用\uxxxx形式表示一个字符，其中xxxx表示字符Unicode码点。\u0061’ == ‘a’;但是这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必输用两个双字节的形式表示。如，’\uD842\uDFB7’ =&gt;  𠮷,  ‘\u20BB7’ =&gt; 7。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">  '\uD842\uDFB7' //  𠮷  '\u20BB7' // 7</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（如\u20BB7），javascript会理解成\u20BB + 7，由于\u20BB 是一个不可打印字符，只会显示一个空格，后面跟着一个7。ES6对此进行了改进，只要将码点放入大括号，就能正确解读该字符。示例</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">  "\u{20BB7}"  //"𠮷"  "\u{41}\u{42}\u{43}"  //"ABC"  let hello = 123;  hell\u{6F}  //123  '\u{1F680}' === '\uD83D\uDE80'   //true</code></pre><h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;javascript内部，字符以UTF-16的格式存储，每个字符固定为2个字节。对于那些需要4个字节存储的字符（Unicode码点大于0xFFFF），javascript会认为他们是两个字符。codePointAt()方法用于正确处理4个字节存储的字符，返回一个字符的码点。示例：</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let s = '𠮷a';    s.codePointAt(0).toString(16) // "20bb7"    s.codePointAt(2).toString(16) // "61"</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编码的问题是解决了，但是codePointAt方法的参数还是不正确，要解决这个问题需要for of循环</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let s = '𠮷a';    for (let ch of s) {        console.log(ch.codePointAt(0).toString(16));    }    // 20bb7    // 61</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    function is32Bit(c) {        return c.codePointAt(0) > 0xFFFF;    }    is32Bit("𠮷") // true    is32Bit("a") // false</code></pre><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。因此String.fromCodePoint方法可以弥补这一点，其实就是将16进制的码点转换成字符，且可以识别4个字节字符</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    String.fromCodePoint(0x20BB7)    // "𠮷"    String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'    // true</code></pre><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    //1.字符串添加了遍历器接口，使得字符串可以for of 循环遍历：示例    for (let basic of 'JavaScript') {        console.log(basic);    }    //J a v a S c r i p t</code></pre><h2 id="at-方法"><a href="#at-方法" class="headerlink" title="at()方法"></a>at()方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。at方法作用同charAt()方法作用相同，返回参数位置的字符，且可以识别码点大于 0xFFFF的字符。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">   'abc'.at(0) // "a"   '𠮷'.at(0) // "𠮷"</code></pre><h2 id="normalize-方法"><a href="#normalize-方法" class="headerlink" title="normalize()方法"></a>normalize()方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许多欧洲语言有语调符号，为了表示它们，Unicode提供了两种方法。一种是直接提供带符号的字符，比如Ǒ（\u01D1）。另一种是提供合成字符，即两个字符合成一个带符号的字符，O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。这两种方法在视觉和语义上都等价，但是JavaScript不能识别，es6解决了这个问题，es6的normalize方法，用来将字符串的不同表示方法统一为永阳的形式，这称为Unicode正规化。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">  '\u01D1'.normalize() === '\u004F\u030C'.normalize()  // true</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normalize()方法可以接受一个参数，表示normalize的方式，参数的四个可选值如下</p><p> NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。<br> NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。<br> NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）<br> NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">  '\u004F\u030C'.normalize('NFC').length // 1  '\u004F\u030C'.normalize('NFD').length // 2</code></pre><h2 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes()/startsWith()/endsWith()"></a>includes()/startsWith()/endsWith()</h2><p> includes(); 返回布尔值，表示是否找到了参数字符串；<br> startsWith();返回布尔值，表示参数字符串是否在原字符串的头部；<br> endsWith();返回布尔值，表示参数字符串是否在源字符串的尾部；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上三个方法均支持第二个参数，表示搜索开始的位置；</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let  strOpApi = 'Hello world';    var isStartWith = strOpApi.startsWith('Hello');    var isIn = strOpApi.includes('llo');    var isEndWith = strOpApi.endsWith('ld');    console.log(isStartWith); //true    console.log(isIn); //true    console.log(isEndWith); //true</code></pre><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat()方法返回一个新的字符串，表示将源字符串重复n次。参数是一个数字，int，如果写小数会自动取整；如果是负数或者infinity则会报错；<a href="区间">-1,0</a>被视为0，NaN视为0；如果传递字符串，则默认会把字符串转化成数字；</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    var xAfterRepeat = 'x'.repeat(3);    console.log(xAfterRepeat);</code></pre><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模板字符串使用<code></code>反引号包裹(如果要在模板字符串中使用反引号，需要转义)，无须拼接，如果模板字符串中欲使用变量，要使用 ${变量} 写在数据的位置，大括号内可以放入任意的js表达式，可以进行运算，以及引用对象的属性，模板字符串中还可以调用函数。<br> 模板字符串还可以嵌套：<br> 使用模板字符串，所有的空格和缩进都会保留在输出中；如果不想要他们，可以用trim方法消除他们；</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let obj = {        a: 'a',        b: 'b',        c: 'c'    };    var str2 = `        &lt;div&gt;            &lt;h2&gt;                这是模板字符串，感觉这么像PHP的界定符？            &lt;/h2&gt;            &lt;ul&gt;                &lt;li&gt;${obj.a}&lt;/li&gt;                &lt;li&gt;${obj.b}&lt;/li&gt;                &lt;li&gt;${obj.c}&lt;/li&gt;                &lt;li&gt;heheheheheh&lt;/li&gt;            &lt;/ul&gt;            `;    $('body').append(str2);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除以上扩展了原来字符串功能外，模板字符串还有标签模板功能；所谓标签模板是指模板字符串紧跟在一个函数名后面，该函数被调用来处理这个模板字符串（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的是函数，紧跟在后面的模板字符串就是它的参数。但是，如果模板字符里面有变量，就不是简单地调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标签模板是将模板字符串转换成一种特殊格式的参数传进函数，也就是说如果你想用标签模板调用函数，那么在编写函数的时候就需要考虑到这种特殊格式；传入函数的参数由：一个数组，和编译替换后的变量，示例：</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    alert`123`;//等同于alert('123');    function tag(strAry, value1, value2, value3){        console.log(arguments);    }    var a = 10, b = 5;    tag`hello ${ a + b } world ${ a  b }`;    //上面调用tag函数后的返回结果；    //  "Hello "    //  " world "    //  ""    //  15    // 50    // "OK"     实际传入函数的参数是样的：(形参定义的时候得个数和下面的结果个数对应)     0: [//这个数组中装的是不需要翻译的字符串          hello,          world,          heheda,          ""     ]//这个数组之外的值都是经过编译和替换后的变量值     1:15     2:50     3:5    function tag(s, v1, v2){        console.log(s[0]);        console.log(s[1]);        console.log(s[2]);        console.log(v1);        console.log(v2);        return 'ok';    }    var total = 30;    var msg = passThru`The total is ${total}(${total  1.05}with tax)`;    //上面这个msg例子展示了，如何将各个参数按照原来的位置拼合回去。    function passThru(literals, value1, value2) {        console.log(arguments);        var result = '';        var i = 0;        while (i &lt; literals.length) {            result += literals[i++];            if (i &lt; arguments.length) {                result += arguments[i];            }        }        return result;    }    console.log(msg);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;字符串数据类型新增了很多功能，其中对Unicode进行了大幅度的增强，新增了若干方法，同时引进了模板字符串，本节只讨论模板字符串的部分功能。&lt;/p&gt;
&lt;h2 id=&quot;字符的Uni
      
    
    </summary>
    
    
      <category term="es6" scheme="http://longfeihouhouhou.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6(2)destructing</title>
    <link href="http://longfeihouhouhou.github.io/es6-2-destructing.md/"/>
    <id>http://longfeihouhouhou.github.io/es6-2-destructing.md/</id>
    <published>2017-09-20T14:00:52.000Z</published>
    <updated>2018-03-20T02:51:56.127Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节讨论解构赋值，解构赋值 destructing :解构赋值:ES6允许按照一定的模式，对变量进行赋值，本质上，这种写法数据“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应位置的值。我觉得这个东东真是个宝，用起来相当的爽。不多说，赶紧练起来吧。</p><h2 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h2><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    //赋值     let catT = 'Tom',     mouseJ = 'Jerry';     let cartoonRole = {catT , mouseJ};     console.log(cartoonRole);//{catT: "Tom", mouseJ: "Jerry"}     //解构     let cartoonRole = {catT:'Tom' , mouseJ: 'Jerry',ok:'hahahha'};     let {catT,ok} = cartoonRole;     console.log(catT,ok);//'Tom' 'hahahha'     //对象的解构与数组有一个重要的不同，数组的元素是按顺序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值；     let {ac, ad} = {ac:'aaa', ad: 'bbb'};     console.log(ac);     //对象的嵌套解构赋值：     let obj1 = {         p:[             'hello',             {y: 'world'}         ]     };     let { p: [ x,  {yy} ] } = obj1;//注意p不是变量是匹配模式，所以是不会被赋值     console.log(x);//hello    //使用对象的解构赋值，可以很方便的将现有的对象的方法赋值到某个变量上，使用起来将会很方便    let {log, sin, cos} = Math;//这行代码将对数，正弦，余弦三个方法赋值到对应的变量上，使用起来将会方便很多；</code></pre><h2 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h2><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">  let cry = ['a','b','c'];  let [h, i, j] = cry; //这相当于声明了三个变量 h i j，这三个值分按照顺序分别对应数组项  console.log(i);//'b'  //复合数组的：  let [ab, [bc, cd], de] = [1, [2, 3], 4];//这时候等号左边的不是数组，只是一个方括号，里面的是单个的变量，可以直接使用  console.log(ab);  //不完全解构的：(但都是成功解构的)  let [fg,[hg],hi] = [1, [2, 3], 4];  console.log(hg);//2  let [jk, lm] = [1, 2, 4];  console.log(lm);//2</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上例可知，解构赋值最重要的就是变量名和对象的key值同名，结构赋值数组时，变量和数组的位置对应，你想取得的值的数量和对象中的key-value数量可以不同，但是要求变量名和key相同，同数组项的位置一致。如果在对象结构赋值时变量同key不同名，那需要特殊处理，即写成key:value的形式，key仍是和对象属性名相同的值，value是进行解构赋值后被赋值的变量（可以和对象的属性名不同）；其中ae是匹配模式，aaa才是真正的变量，真正被赋值的是变量aaa不是ae，还要注意一点，采用这种写法时，变量的声明和赋值时一体的，对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错；</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    //对象的解构与数组有一个重要的不同，数组的元素是按顺序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值；    let {ac, ad} = {ac:'aaa', ad: 'bbb'};    console.log(ac);// 'aaa'    //key同变量名不同名    let {ae:aaa} = {ae:'hhhhhh'};    console.log(aaa);</code></pre><h2 id="字符串解构赋值"><a href="#字符串解构赋值" class="headerlink" title="字符串解构赋值"></a>字符串解构赋值</h2><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">   //字符串也可以解构赋值，因为此时，字符串被转换成了一个类数组对象；   const [ai, aj, ak, al, am] = 'hello';   console.log(ai);//h   //类数组对象有一个length属性，因此还可以对这个属性解构赋值。   let {length:len} = 'hello';   console.log(len);//5</code></pre><h2 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果等号的右边不是数组（或者严格的说，不是可遍历的结构：对象、数组、set对象、map对象等）那么将报错；事实上，只要某种数据结构具有Iterator接口，都可以采用数据形式的解构赋值。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let [uv, vw, wx] = new Set(['a', 'b', 'c']);    console.log(uv); //a</code></pre><h2 id="结构赋值时设置默认值"><a href="#结构赋值时设置默认值" class="headerlink" title="结构赋值时设置默认值"></a>结构赋值时设置默认值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构赋值允许指定默认值。但是注意：ES6中使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的；</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let [xy = true] = [];    console.log(xy);//true    let [yz = 'undefined'] = [null];//null 不严格等于undefined，所以默认值是不生效的    console.log(yz);//null    //如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候才会求值；    function faaa(){        console.log('abacd');    }    let [xb = faaa()] = [1];//这行代码中，因为xb能取到值，所以函数f根本不会执行；    //解构赋值时的默认值可以引用其他解构赋值的变量，但是这个变量必须已经声明过；    let [xc = 1, yc = xc] = [];    let [aa = bb,bb = 1] = [];//referenceError，因为引用给aa用到默认值(如果用不到就不会报错)，给默认值赋值时，bb还没    //对象结构赋值也可以指定默认值，同样默认值生效的条件：对象的属性值严格等于undefined。如果解构失败，变量将会被赋值undefined;    let {ag = 3} = {x:undefined};    console.log(ag);//3</code></pre><h2 id="函数参数解构赋值"><a href="#函数参数解构赋值" class="headerlink" title="函数参数解构赋值"></a>函数参数解构赋值</h2><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">//函数的解构赋值意义是：函数形参设置的时候可以设置成数组或者对象，但是通过解构，在函数体内得到的就是一个一个的值function add([x, y]){    //console.log(arguments);//通过打印arguments，我们发现，函数收到的参数其实是单个的数字，而非数组    return x + y;}var total = add([1, 2]);console.log(total);//3var arr = [[1,2,3],[3,4,5]].map(([a, b, c]) => a + b + c);//map方法经过操作后会映射成一个新的数组，而且map方法的第一个参数是数组项，而经过参数解构赋值后 得到 a=1,b=2,c=3 ，执行一次回调，将原数组第一项映射成6，以此类推console.log(arr);//[6, 12]//参数解构赋值也可以使用默认值function move({an = 0, ao = 0} = {}){    return [an, ao];}var ar1 = move({an: 1, ao: 2});console.log(ar1);//[1, 2]var ar2 = move();//{an = 0, ao = 0} = {} 这么写是为了给函数的实参一个默认值{}，当不传的时候就是空对象{}console.log(ar2);//[0, 0]</code></pre><h2 id="解构赋值应用场景"><a href="#解构赋值应用场景" class="headerlink" title="解构赋值应用场景"></a>解构赋值应用场景</h2><h3 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h3><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let ap = 1;    let aq = 2;    [ap, aq] = [aq, ap];    console.log(ap);//2</code></pre><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p>原则上函数只能返回一个值，如果要返回多个值，只能将他们放在数组或者对象中，有了解构赋值，去除这些值将会非常的方便；</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    function eg1(){        return [1, 2, 3];    }    let [ar, as, at] = eg1();    console.log(ar);//1    function eg2(){        return {            au:'www',            av:'itouzi',            aw:'com',        }    }    let {au:ax, av:ay, aw:az} = eg2();    console.log(ay);//itouzi</code></pre><h3 id="提取json数据-解构赋值对提取JSON对象中的数据尤其有用；"><a href="#提取json数据-解构赋值对提取JSON对象中的数据尤其有用；" class="headerlink" title="提取json数据:解构赋值对提取JSON对象中的数据尤其有用；"></a>提取json数据:解构赋值对提取JSON对象中的数据尤其有用；</h3><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    let json = {        id: 42,        status: 'ok',        data: [333, 444]    };    let {id ,status, data} = json;    console.log(data);//[333, 444]</code></pre><h3 id="函数参数设置默认值"><a href="#函数参数设置默认值" class="headerlink" title="函数参数设置默认值"></a>函数参数设置默认值</h3><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    function plus([x = 0,y = 0] = []){        return x + y;    }    console.log(plus());//0</code></pre><h3 id="遍历Map解构"><a href="#遍历Map解构" class="headerlink" title="遍历Map解构"></a>遍历Map解构</h3><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    for (let [key, value] of map) {        //console.log(key + ' is ' + value);    }    //只获取键    for (let [key1] of map) {        console.log(key1);    }    //只获取值    for (let [, value1] of map) {        //console.log(value1);    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本节讨论解构赋值，解构赋值 destructing :解构赋值:ES6允许按照一定的模式，对变量进行赋值，本质上，这种写法数据“模式匹配”，只要等号两边的
      
    
    </summary>
    
    
      <category term="es6" scheme="http://longfeihouhouhou.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>ES6(1) let和const</title>
    <link href="http://longfeihouhouhou.github.io/ES6-1-let%E5%92%8Cconst.md/"/>
    <id>http://longfeihouhouhou.github.io/ES6-1-let和const.md/</id>
    <published>2017-09-12T14:32:25.000Z</published>
    <updated>2018-03-20T02:51:27.473Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这篇文章起，后面将会有一系列的文章和大家探讨es6，现在才说es6好像有点晚了，但是我们的前端团队还没有大规模应用es6。一直以来我也零零星星的学过一些es6，早在几年前就了解过，但是始终没有系统的学习过，这一次做分享，也是对自己的一个激励，争取这个系列可以覆盖全部的es6特性。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在es6以前，ECMAScript是没有块级作用域的，这就带来了很多意外的情况，比如经典的for循环问题。</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    例 1：    var a = [];    for (var i = 0; i < 10; i++) {        a[i] = function (){            console.log(i);        }    }    a[3]();//10</code></pre><p>引入块级作用域后</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    例 2：    var a = [];    for (let i = 0; i < 10; i++) {        a[i] = function (){            console.log(i);        }    }    a[3]();//3</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看了上面两段代码，块级作用域就是除字面量声明对象（{key: value}）以外的花括号代码块都构成块级作用域，但是现在有个问题值得思考。大家都知道，在js中变量是存在于作用域中的，在上面例1中，var i = 0;i存在的作用域就是全局（for循环外围无函数）作用域，所以for循环的i++每次都会修改全局作用域中的i。那么改成let声明后，变量的保存的作用域是不是改变了呢？下面代码我们模拟了块级作用域（不是很严谨，只是按照自己的猜测），其中循环体中的闭包模拟块级作用域。很显然，每次for循环（let声明）的循环体（花括号空的代码）执行一次就声明了一个块级作用域，变量i就保存在了块级作用域中，按照作用域查找机制，块级作用域延长了作用域链。同时由于数组a的引用，这个块级作用域并不会销毁，因而变量值得以保存。（仅个人理解）</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    var a = [];    for (var i = 0; i < 10; i++) {        a[i] = (function (i){            return function () {console.log(i)}        })(i);    }    a[3]();//3</code></pre><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>使用let 和 const将带来的暂时性死区：只要块级作用域内存在let命令，它所声明的变量就绑定在这个区域，不再受外部的影响。示例：</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    var tmp = 123;    if (true) {        tmp = 'abc';        let tmp;    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let语句之前调用变量，就会报错；ReferenceError；暂时性死区也意味着typeof不再是一个百分百安全的操作，因为你typeof这个变量仍然是访问变量，仍然会报错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与此同时，另一不可忽略的事实产生了，var除是用于变量声明的关键字，还具有变量提声（javascript预解释）的作用。而let和const并无此作用，仅用于变量的声明，因此在使用let和const声明的变量时，确认这些变量在被引用前（代码顺序）是否被声明将变得意义非同寻常。示例</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">    console.log(tmp);//undefined    var tmp = 123;    if (true) {         console.log(wrong);//ReferenceError         let wrong = 'abc';    }</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三，同var不同的是，let和const不允许重复声明。示例</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">   function foo(declareParam){       let declareParam = 0; //报错  'declareParam' has already been declared   }   foo('aaa');//报错   但是得在方法执行的时候才报错   //但是请注意这种在块级作用域中的声明并不会收到这一影响   function fooWithBlockZone(declareParam){       { //这一花括号是块级作用域           let declareParam = 14;//这个不会报错       }   }   fooWithBlockZone('aa');//不报错</code></pre><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const的作用域和let一样：只在声明所在的块级作用域内有效。const声明的常量也不存在变量提声，同样存在暂时性死区，只能在声明的位置后面使用。同样不能重复声明一个变量；const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动，对于简单的数据类型（数值，字符串，布尔值），值就保存在保存变量指向的那个内存地址，因此等同于常量。但是对于复合型数据额类型（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于他的指向的数据结构是否是不是可变的，就完全不能控制了，因此，将一个对象声明为常量必须非常小心；什么意思呢？就是说啊：当使用const声明一个复杂数据类型时，这个const只能保存指向这个复杂数据类型的地址不被改变，但是这个复杂数据类型的数据仍然可以操作：示例:</p><pre style="background: #00b38a;"><code lang="javascript" style="color: yellow;font-size: 12px;background: #00b38a;">  const objConst = {};  objConst.testAddPropIntoConstObj = 'yes,you guess it';  console.log(objConst);//虽然声明的是常量，但是给这个对象的内存地址中的内容还是可以操作的；  //如果你真想声明一个不可以修改的对象使用Object.freeze({})方法；示例  const objFrozen = Object.freeze({});//声明一个冻结常量；  objFrozen.prop = 'No,what a pity,what you guess is thoroughly wrong!';  //严格模式下使用这一行代码报错  //非严格模式不理会这行代码；  console.log(objFrozen);</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，在ES5中，在全局中声明的变量和挂载在全局中的属性是等价的，从ES6开始，全局变量将和顶层对象的属性脱离，为了改变这一点，一方面规定，为了保持兼容性，var 和 function声明的全局变量扔等同于顶层对象window/global的属性，但是使用let、const、class声明的全局变量不属于顶层对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从这篇文章起，后面将会有一系列的文章和大家探讨es6，现在才说es6好像有点晚了，但是我们的前端团队还没有大规模应用es6。一直以来我也零零星星的学过一些es6，早在几年前就了解
      
    
    </summary>
    
    
      <category term="es6" scheme="http://longfeihouhouhou.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>react入门</title>
    <link href="http://longfeihouhouhou.github.io/react%E5%85%A5%E9%97%A8.md/"/>
    <id>http://longfeihouhouhou.github.io/react入门.md/</id>
    <published>2017-09-09T12:11:06.000Z</published>
    <updated>2018-03-19T09:42:07.488Z</updated>
    
    <content type="html"><![CDATA[<p>#初识react</p><p>[toc]</p><p>##react安装<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm </span><span class="string">install </span><span class="built_in">create-reacte-app</span> -g</span><br><span class="line"><span class="built_in">create-reacte-app</span> <span class="string">my </span><span class="string">app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app</span></span><br><span class="line"><span class="string">npm </span><span class="string">start</span></span><br></pre></td></tr></table></figure></p><hr><p>##JSX简介<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p><p>这种标签语法不是html也不是字符串，而是JSX，一种javascipt语法扩展，在React中推荐使用jsx来描述用户界面<br><strong>使用</strong></p><ul><li>可以任意的在jsx中使用js表达式, 但是要包含在大括号中。</li><li>在书写jsx时候 一般带上换行和缩进，增强代码可读性, 推荐在jsx代码外扩上一个小括号，放置分号自动插入的bug</li><li>jsx本身也是一种表达式，也就是说可以在if 或者for语句使用jsx，将他赋值给变量，当作参数传入，作为返回值。</li><li>属性:<br>  使用引号来定义以字符串为值的属性，使用大括号来定义以js表达式为值的属性<br><strong>JSX代表Object</strong><br>Babel转译器会把jsx转换成一个名为React.createElement()的方法调用。这个方法会返回一个对象，这样的对象被称为 React元素，react通过读取这些对象来构建DOM并保持数据一致<br>##元素渲染<br>元素是构成React应用的最小单位<br>React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">渲染方法</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>##React组件<br><strong>组件定义的方式</strong><br>第一种：js普通函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种： es6类<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件，这个对象称之为”props”</p><blockquote><p> 警告:<br> 组件名称必须大写字母开头 </p></blockquote><p>React非常灵活，但是有一个严格的规则：<br><strong>所有的React组件必须像纯函数那样使用他们的props</strong></p><blockquote><p>纯函数： 函数执行不会改变自己的输入值，当传入值相同时总能返回相同的结果</p></blockquote><p>##state状态<br><strong>将函数转换为类</strong></p><ol><li>创建一个名称扩展为React.Component的ES6类</li><li>创建一个叫做render( )的空方法</li><li>将函数体移动到render( )方法中</li><li>在render( )方法中，使用this.props替换props</li><li>删除剩余空函数声明</li></ol><p>使用类才能允许我们使用其他特性，例如局部状态，生命周期钩子<br><strong>给一个类添加局部状态</strong></p><ol><li>在render方法中使用this.state.date替代this.props.date</li><li>添加一个类构造函数来初始化this.state</li><li>从 <code>&lt;Clock/&gt;</code>元素移除date属性</li></ol><p>结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>接下来，使用Clock设置计时器，每秒刷新一次，这样就会用到生命周期</p><p>##生命周期<br>每当Clock组件第一次加载到DOM中的时候，我们都想生成定时器，这在React中被称为挂载。</p><p>同样，每当Clock生成的这个DOM被移除的时候，我们也会想要清除定时器，这在React中被称为卸载。</p><p>我们可以在组件类上声明特殊的方法，当组件挂载或卸载时，来运行一些代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span>&#123;<span class="comment">//建立定时器</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span> &#123;<span class="comment">//卸载定时器</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这些方法被称作生命周期钩子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>让我们回顾下发生了什么，一级调用方法的顺序</p><ol><li>当<code>&lt;clock/&gt;</code>被传递给ReactDOM.render( )时, React调用Clock组件的构造函数。由于Clock需要显示当前时间，所以使用包含当前时间的对象来初始化this.state。我们稍后会更新此状态</li><li>然后 React 调用Clock组件的render( )方法. 这是React 了解屏幕上应该显示什么内容的原因，然后React更新Dom 以匹配Clock的渲染输出。</li><li>让clock的输出插入到DOM中时，React调用componentDidMount( )生命周期钩子.在其中，clock组件要求浏览器设置一个定时器，每秒执行一次</li><li>浏览器每秒调用tick( )方法，在其中Clock 组件通过使用包含当前的对象，调用setState( )来调度UI更新。 通过调用setState( )，React知道状态已经改变 ，并再次调用render( )方法来确定屏幕上应当显示什么，这一次render( )方法中的this,state.date将不同, 所以渲染输出将包含更新的事件，并响应的更新DOM.</li><li>一旦Clock组件被从Dom中移除，React会调用componentWillUnmount( )这个钩子函数，定时器也就会被清除</li></ol><p>##正确的使用状态<br>关于<code>setState()</code>的三件事情：<br><strong>1 不要直接更新状态</strong><br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.<span class="keyword">state</span>.comment = 'Hello';</span><br></pre></td></tr></table></figure></p><p>应该使用setState( )<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="string">comment:</span> <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>构造函数是位移能够初始化<code>this.state</code>的地方。<br><strong>状态更新可能是异步的</strong><br>React可以将多个setState( )调用 合并成一个调用来提高性能。<br>因为this.props和this.state可能是异步更新的，不应该靠他们的值来计算下一个状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#初识react&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;##react安装&lt;br&gt;&lt;figure class=&quot;highlight dsconfig&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="react" scheme="http://longfeihouhouhou.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-redux的状态管理</title>
    <link href="http://longfeihouhouhou.github.io/react-redux%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.md/"/>
    <id>http://longfeihouhouhou.github.io/react-redux的状态管理.md/</id>
    <published>2017-09-09T05:08:23.000Z</published>
    <updated>2018-03-19T09:42:07.472Z</updated>
    
    <content type="html"><![CDATA[<p>##Redux</p><p>[toc]</p><p>###1.Redux应用场景<br>因为单页面应用内容越来越复杂，所以管理不断变化的state非常困难，在React中，数据在组件中是单向流动的，兄弟组件之间的通信就会比较麻烦<img src="./redux-wrong.png" alt="Alt text"></p><p>###2. Redux设计思想</p><ul><li>Redux是将整个应用状态存储到一个地方，称为store,里面保存一颗状态树(<code>state  tree</code>)。（因为状态一般都用对象，而对象都是树形结构）组件可以派发(dispatch) 行为 action 给store，而不是直接通知其他组件。组件内部通过订阅store中的状态state 来刷新自己的视图。<br><img src="./redux-flow.png" alt="Alt text"><br>###3. Redux三大原则</li></ul><ol><li>整个应用的state被储存在一颗object tree中，并且存在一个唯一一个store中</li><li>state是只读的，唯一改变state的方法就是触发action ，action是一个用于描述已发生事件的普通对象</li><li>使用纯函数来执行修改，为了描述action 如果改变state tree 你需要编写reducers</li></ol><ul><li>单一数据源的设计让React的组件之间的通信更加方便，同时便于状态的统一管理<br>###4.Redux解析概念</li></ul><hr><ul><li><p>4.1 Store</p><ul><li>store 就是保存数据的地方，可以把它看成一个容器，整个应用只能有一个store</li><li><p>Redux 提供createStore 方法，用来生成store </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(fn)</span><br></pre></td></tr></table></figure><p>  上面代码中createStore函数接受另一个函数作为参数，返回新生成的store对象。</p></li></ul></li><li><p>4.2 State<br>  Store对象包含所有数据，如果想要得到某个时点的数据，就要对Store生成快照。这种时间点的数据集合，就叫做State。当前时刻的State，可以通过store.getState( )拿到。</p>  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore&#125; <span class="keyword">from</span> 'redux'</span><br><span class="line">const store=createStore(fn)</span><br><span class="line">const <span class="keyword">state</span>=store.getState()</span><br></pre></td></tr></table></figure><ul><li><p>4.3 Action<br>  state的变化会导致view的变化，但是用户接触不到State，只能解触到view，所以state的变化必须是view导致的。action就是view发出的通知，表示state应该快要发生变化了，action是一个对象。其中的type属性是必须的，表示action的名称。其他属性可以自由设置，社区有一个规范可以参考</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action=&#123;</span><br><span class="line"><span class="keyword">type</span>:<span class="string">'ADD_TODO'</span>,</span><br><span class="line">playload:<span class="string">'学习Redux'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码中，action的名称是ADD_TODO，它携带的信息是字符串’学习Redux’ 这样可以理解，action描述当前发生的事情，可以改变State的唯一办法，就是使用ation ，它可以运送数据到Store</p></li></ul></li><li>4.4 Action Creator<br>view要发送多少种信息，就会有多少种action，如果都手写太麻烦，可以定义一个函数来生成action，这个函数就叫action creator<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加TODO'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span><span class="params">(text)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">type:ADD_TODO,</span><br><span class="line">text</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> action=addTodo(<span class="string">'学习Redux'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，addTodo函数就是一个Action Creator</p><ul><li><p>4.5 store.dispatch()<br>  store.dispatch() 是view发出action的唯一方法。</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> store=createStore(fn)</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line"><span class="keyword">type</span>:<span class="string">'ADD_TODO'</span>,</span><br><span class="line">payload:<span class="string">'学习Redux'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  上面代码中store.dispath 接受一个action对象作为参数，将它发送出去，结合Action Creator，这段代码可以改写如下。</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">store</span><span class="selector-class">.dispatch</span>(addTodo(<span class="string">'学习Redux'</span>))</span><br></pre></td></tr></table></figure></li><li><p>4.6 Reducer<br>Store收到Action以后，必须给一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个纯函数，它接受Action和当前state作为参数，返回一个新的State。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer =<span class="function"><span class="keyword">function</span><span class="params">(state,action)</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何使用redux"><a href="#如何使用redux" class="headerlink" title="如何使用redux"></a>如何使用redux</h2><ol><li>后台写一个后台接口  /lessons</li><li>前台(api)里写一个获取接口数据的方法</li><li>在action-types里添加新的actionType类型</li><li>在reducer里修改初始状态，并添加一个case</li><li>在<code>actions</code>里添加一个方法调用此方法</li><li>在组件中调用action中的方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##Redux&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;###1.Redux应用场景&lt;br&gt;因为单页面应用内容越来越复杂，所以管理不断变化的state非常困难，在React中，数据在组件中是单向流动的，兄弟组件之间的通信就会比较麻烦&lt;img src=&quot;./redux-wro
      
    
    </summary>
    
    
      <category term="react" scheme="http://longfeihouhouhou.github.io/tags/react/"/>
    
      <category term="react-redux" scheme="http://longfeihouhouhou.github.io/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>html5的web语义化</title>
    <link href="http://longfeihouhouhou.github.io/html5%E7%9A%84web%E8%AF%AD%E4%B9%89%E5%8C%96.md/"/>
    <id>http://longfeihouhouhou.github.io/html5的web语义化.md/</id>
    <published>2017-07-06T11:39:59.000Z</published>
    <updated>2018-03-19T09:42:07.583Z</updated>
    
    <content type="html"><![CDATA[<p>##<code>Web</code>语义化<br>[toc]</p><blockquote><p>通俗讲<code>web语义化</code>就是合适的标签干合适的事儿，其优点在于标签语义化有助于构架良好的<code>html</code>结构，构建清晰的结构，便于开发、维护。有利于<code>搜索引擎</code>的<code>建立索引</code>、<code>抓取</code>；同样有利于页面在<code>不同的设备</code>上显示尽可能相同；</p><ul><li><ol><li>有利于搜索</li></ol></li><li><ol><li>容易兼容不同设备</li></ol></li><li><ol><li>结构清晰，便于开发、维护。</li></ol></li></ul></blockquote><p>##如何构建web语义化的页面？</p><ul><li><p><code>h1</code>-<code>h6</code>的规划</p><blockquote><p>一篇文章应该只有一个总标题<code>h1</code>,然后根据文章的具体内容，若干个<code>h2</code>及嵌套的<code>h3</code>…</p></blockquote></li><li><p><code>p</code>标签的使用</p><blockquote><p>每一个段落都应该用<code>p</code>去表示，默认情况下<code>p</code>是有一定的缩进及行距。如果不想这样排版，应该另外写<code>css</code>去控制</p></blockquote></li><li><p><code>ul</code>、<code>ol</code>、<code>li</code>的使用</p><blockquote><p>li必须是在ul或者ol里面，当我们只是列举一些数据，但又达不到一个分论点这种语义时，或者在一些咨询的网站新闻列表中，都应该用此语义标签。</p></blockquote></li><li><p><code>header</code>、<code>nav</code>、<code>article</code>、<code>section</code>、<code>aside</code>、<code>footer</code>标签的关系<br><img src="http://images.cnitblog.com/i/84053/201403/072109412842073.jpg" alt="明细内容页的语义化"></p></li><li><p><code>th</code>、<code>tbody</code></p><blockquote><p>表格的表头及重复列表内容，正常的表格都应该区分表头及表体内容。表头默认是加粗并且居中的。</p></blockquote></li><li><p><code>address</code></p><blockquote><p>表示联系方式，方便爬虫立马找到你的联系方式。<br>其他的不常见，就不列举了</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;code&gt;Web&lt;/code&gt;语义化&lt;br&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通俗讲&lt;code&gt;web语义化&lt;/code&gt;就是合适的标签干合适的事儿，其优点在于标签语义化有助于构架良好的&lt;code&gt;html&lt;/code&gt;结构，构建清晰的结构，便于开发
      
    
    </summary>
    
    
      <category term="html" scheme="http://longfeihouhouhou.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>初识express</title>
    <link href="http://longfeihouhouhou.github.io/%E5%88%9D%E8%AF%86express.md/"/>
    <id>http://longfeihouhouhou.github.io/初识express.md/</id>
    <published>2017-06-09T06:54:54.000Z</published>
    <updated>2018-03-19T09:42:07.472Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><ul><li><p>express是一个简洁快速node.js开发框架<br>##使用express</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> express</span><br></pre></td></tr></table></figure></li><li><p>获取、引用 通过变量app我们就可以调用express的各种方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">express</span> = require('<span class="built_in">express</span>');</span><br><span class="line"><span class="built_in">var</span> app = <span class="built_in">express</span>();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p>###练习</p><ul><li>当客户端以get方式访问</li><li>如果有一天，你忘记了请求和响应的格式。 打开gitbash<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入　</span><br><span class="line">curl <span class="params">--verbose</span> http:<span class="string">//localhost</span><span class="function">:8080</span>/user</span><br><span class="line">curl <span class="params">--verbose</span> <span class="params">--data</span> <span class="string">"name=zfpx"</span> -X POST http:<span class="string">//localhost</span><span class="function">:8080</span>/user</span><br></pre></td></tr></table></figure></li></ul><p>##send 方法</p><ul><li>send 方法可以接受任何类型的参数：字符串 buffer 对象  数组 数字 ，主要是数据类型转换 ，把其他类型都转成end能处理的类型，也就是字符串或者buffer</li><li>发送文件的sendFile 但是需要绝对路径，或者指定root根目录</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;express是一个简洁快速node.js开发框架&lt;br&gt;##使用express&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nodeJs" scheme="http://longfeihouhouhou.github.io/tags/nodeJs/"/>
    
  </entry>
  
  <entry>
    <title>GIT进阶操作</title>
    <link href="http://longfeihouhouhou.github.io/GIT%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C.md/"/>
    <id>http://longfeihouhouhou.github.io/GIT进阶操作.md/</id>
    <published>2017-05-16T10:34:49.000Z</published>
    <updated>2018-03-19T09:42:07.583Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在做团队项目时会使用GIT来进行团队分工和配合，那么正确使用GIT的流程是什么样子的呢，分支又是如何利用的呢？</p><ul><li>最开始我们在<code>git hub</code>上创建一个仓库，然后在项目的setting选项中选择<code>Collaborators</code>，通过用户名来邀请合作者，邀请发出后，被邀请额合作者会在绑定邮箱中收到邀请函。接受邀请后就可以一同开发这个在GIT上的项目了</li><li>我们会首先使用<code>git clone https://github.com/xxxxx/xxxxxx.git</code>指令在<code>git bash</code>命令行中来将仓库下载下来，当你推送修改的时候要使用<code>git push origin master</code>指令推送。不过在<code>git push</code>之前 必须要执行 <code>git add .</code>和<code>git commit -m&#39;本次提交名字&#39;</code>  两个步骤操作，这个是必须的，要弄白为什么，就得理解<code>git hub</code>的三个分区。</li><li><code>git hub</code>有三个分区，分别是 <code>工作区</code> <code>暂存区</code> <code>历史区</code> <ul><li>工作区指的是当前当前代码编辑进行区域，暂存区是执行<code>git add</code>指令后文件暂存的区域，而历史区则是你的版本历史区域，也就是说你可以有多个历史区文件，但是暂存区只有一个（只有一个分支情况下），那么暂存区和历史区有什么必要性呢？</li><li>先说历史区，他能收集你多个时间段的代码，多个时间段的版本也就是<code>git commit</code>，多次提交的版本，例如 1.0版 1.1版 2.1版，当你代码出错找不到解决办法的时候，可以使用版本回退，来回到你想回到的版本，而<code>git commit -m</code>后面的字段就是版本的名称，所以写好版本名是非常有必要的</li><li>再说暂存区，说到暂存区就不得不提及<code>git</code>  分支的好处了，当同时有多人开发同一个项目时，难免会出现冲突，所谓冲突就是多个人对同一个文件进行了不同的修改，例如<code>README</code>文件的第一行，如果张三和李四都对这个文件的第一行进行了修改，并且是有差异的修改，那么<code>git hub</code> 会对这两个两个修改表示出无法处理，它不知道第一行到底是接受张三的还是李四的。</li></ul></li><li><p>所以一般我们在提交代码之前先要使用<code>git pull origin master</code>将<code>git hub</code>仓库中最新的代码在本地更新一下，但是这就是导致了工作区（也就是当前编辑区）下的代码会受到干扰，因为拉下的文件也可能与工作区下的代码冲突，所以这个时候，如果我们将当前的修改放到一个区域，拉下来的代码放到另一个区域，再将这两个区域进行合并就方便多了，而暂存区就是用来存放代码的，我们可以通过<code>git add .</code>指令将工作区代码存放到暂存区，然后通过<code>git pull origin master</code>指令将<code>GIT</code>仓库中最新的版本更新到工作区，但是这样虽然达到了工作区内容是<code>GIT</code>仓库最新版，暂存区内容是我编辑的最新版的目的，但是如何进行智能的合并呢？这就涉及到了分支问题。</p><blockquote><p>默认情况下，只有一个主分支:  <code>master</code> ，我们可以通过<code>git checkout -b &#39;xxxx&#39;</code>来创建一个名为<code>xxxx</code> 的分支，然后通过 <code>git checkout xxxx</code>来进行分支切换, 通过<code>git branch</code>指令查看所有分支 ，通过<code>git merge xxxx</code>合并分支，通过<code>git branch -D xxxx</code>删除分支，值得注意的是你可以合并、删除任何分支，但是不能在当前分支下进行删除当前分支的操作。</p></blockquote></li><li><p>如果我们在<code>git pull</code>之前 创建一个分支例如<code>git checkout -b &#39;loong&#39;</code>，通过<code>git add .</code>将我的修改添加到<code>loong</code>分支的暂存区上，再切换回主分支<code>git checkout master</code> 然后在进行<code>pull pull</code>操作，  将<code>GIT</code>仓库最新版本更新到本地主分支上面，这就相当于主分支<code>master</code>下的文件和<code>git hub</code>上是一致的，而<code>loong</code>分支上是我的修改。这样就实现了我既有了网上最新的版本，分支上也有了我当前修改的版本。这个时候我们就可以将两个分支进行合并，从而获得完全体的最新版本。</p><blockquote><p>假如我们不使用分支，直接将工作区内容添加到暂存区，然后跟新本地<code>master</code>，这样虽然达到了工作区是网上最新的版本，暂存区是我的修改，但是无法达到代码合并的目的。</p></blockquote><ul><li>在主分支上通过 <code>git merge loong</code>指令将分支合并到主分支，然后通过<code>git add .</code>，<code>git commit -m&#39;提交版本名&#39;</code>, <code>git push origin mstare</code>指令将合并完成后的代码推送到<code>git hub</code>仓库<blockquote><p>如果这个时候分支名从<code>master</code>变成<code>Merging|Master</code>那就说明你的修改和<code>GIT</code>仓库上最新的版本有了冲突，你可以到编辑器内进行冲突处理，然后再<code>git push</code>这种冲突是具体到某一个文件的某一行的差异，是比较好处理的。</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们在做团队项目时会使用GIT来进行团队分工和配合，那么正确使用GIT的流程是什么样子的呢，分支又是如何利用的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最开始我们在&lt;code&gt;git hub&lt;/code&gt;上创建一个仓库，然后在项目的setting选项中选择&lt;code&gt;Collab
      
    
    </summary>
    
    
      <category term="Git" scheme="http://longfeihouhouhou.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>GIT的使用指南</title>
    <link href="http://longfeihouhouhou.github.io/GIT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md/"/>
    <id>http://longfeihouhouhou.github.io/GIT的使用指南.md/</id>
    <published>2017-05-09T14:34:33.000Z</published>
    <updated>2018-03-19T10:20:27.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT-使用指南"><a href="#GIT-使用指南" class="headerlink" title="GIT 使用指南"></a>GIT 使用指南</h1><p>[toc]</p><h2 id="git-特性"><a href="#git-特性" class="headerlink" title="git 特性"></a>git 特性</h2><p>-&gt; 管理代码版本的工具（分布式git） </p><ul><li>能记住是谁提交的东西</li><li>保存每个阶段的内容（备份功能）</li><li>可以实现时空裂缝功能</li><li>GitHub 开源  多端共享 团队协作</li><li>自动合并代码，比较不同<br>-&gt; 区别集中式 svn<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2></li><li>下载git</li><li>通过鼠标右键 git bush  here 使用git 命令行</li><li>查看 git 版本<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="comment">--version</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用git"><a href="#使用git" class="headerlink" title="使用git"></a>使用git</h2><ul><li>界面化操作GUI ( source tree)</li><li>命令行操作c l i<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name zhufengzhufeng</span><br><span class="line">git congif --global user.email 695409705@qq.com</span><br></pre></td></tr></table></figure></li></ul><p>-&gt;告诉git 是谁提交的代码</p><h2 id="初始化git-不能嵌套使用git"><a href="#初始化git-不能嵌套使用git" class="headerlink" title="初始化git(不能嵌套使用git)"></a>初始化git(不能嵌套使用git)</h2><ul><li>以某个文件夹作为git管理的目录<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure></li></ul><p>-&gt; 会产生一个.git文件夹</p><h2 id="提交到git前-查看暂存区是否存在"><a href="#提交到git前-查看暂存区是否存在" class="headerlink" title="提交到git前 查看暂存区是否存在"></a>提交到git前 查看暂存区是否存在</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure><p>-&gt; 如果是红色便是未添加到暂存区</p><ul><li>添加到暂存区<ul><li>git add 文件名</li><li>或者 git add .   提交所有<h3 id="提交到历史区"><a href="#提交到历史区" class="headerlink" title="提交到历史区"></a>提交到历史区</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"initial"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>单纯的git commit 会进入编辑器 可以直接通过-m +”本次提交日志”来便捷提交 </p></blockquote><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  <span class="built_in">log</span></span><br></pre></td></tr></table></figure><blockquote><p>查看所提交过的文件及历史</p></blockquote><h2 id="比较三个阶段文件区别"><a href="#比较三个阶段文件区别" class="headerlink" title="比较三个阶段文件区别"></a>比较三个阶段文件区别</h2><ul><li><p>工作区和暂存区</p><pre><code><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git diff</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>比较暂存区和历史区</p><pre><code><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment">--cached</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>比较工作区和历史区</p><pre><code><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git diff mater</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><blockquote><p>如果一样则不显示</p><ul><li>时空裂缝<ul><li>工作区回到暂存区内容<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 文件名</span><br><span class="line"> ``` </span><br><span class="line"> - 将暂存区内容返回到上一次</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><pre><code>git reset HEAD 文件名<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>查看历史版本</span><br></pre></td></tr></table></figure>git reflog 版本号<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>回到历史版本</span><br></pre></td></tr></table></figure>git reset --hard 版本号<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 分支</span></span></span><br><span class="line">- 查看分支</span><br></pre></td></tr></table></figure></code></pre><p>git branch<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-创建分支</span></span><br></pre></td></tr></table></figure></p><p>git checkout -b 分支名<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>切换分支</span><br></pre></td></tr></table></figure></p><p>git checkout 分支名<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>创建并切换分支名</span><br></pre></td></tr></table></figure></p><p>git checkout -b dev<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>删除分支</span><br></pre></td></tr></table></figure></p><p>git branch -D 分支名  但是不能删除当前分支<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt;每个分支是没有关`enter <span class="keyword">code</span> here`系的</span><br><span class="line">- 分支合并</span><br></pre></td></tr></table></figure></p><p>git merge dev<br><code>`</code></p><h2 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h2><ul><li>pwd  打印当前路径</li><li>rm -rf  .git  (删除文件夹)</li><li>mkdir 创建目录</li><li>ls （list show 查看目录）</li><li>cd -git-pro/ (进入文件夹)</li><li>创建一个文本并在命令行编辑<ul><li>touch 文件名</li><li>vi 文件名</li><li>i 插入模式</li><li>esc + :wq 保存推出</li><li>cat 文件名 （查看文本内容） </li></ul></li></ul><p><code type="javascript" style="background: #00b38a"></code></p><p>var ab = ‘1223’;</p><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GIT-使用指南&quot;&gt;&lt;a href=&quot;#GIT-使用指南&quot; class=&quot;headerlink&quot; title=&quot;GIT 使用指南&quot;&gt;&lt;/a&gt;GIT 使用指南&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;git-特性&quot;&gt;&lt;a href=&quot;#git-特性&quot; cl
      
    
    </summary>
    
    
      <category term="Git" scheme="http://longfeihouhouhou.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>flex布局和弹性盒子</title>
    <link href="http://longfeihouhouhou.github.io/flex%E5%B8%83%E5%B1%80%E5%92%8C%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90.md/"/>
    <id>http://longfeihouhouhou.github.io/flex布局和弹性盒子.md/</id>
    <published>2017-04-03T05:32:51.000Z</published>
    <updated>2018-03-19T09:42:07.535Z</updated>
    
    <content type="html"><![CDATA[<p>##CSS3弹性盒子flex布局</p><blockquote><p>弹性盒子是css3一种新的布局模式，他能更有效的对元素进行排列，对齐，分配空间。弹性盒子外和子元素内是正常渲染的，弹性盒子只定义了<code>弹性子元素</code>如何<code>在弹性容器</code>内渲染。弹性子元素默认每个容器只有一行，弹性子元素在弹性盒子内一行显示</p></blockquote><ol><li><p>direction：</p><blockquote><p>设置<code>direction</code>属性为<code>rtl</code>(right-to-left)弹性子元素排列改变，页面布局也会跟变化</p></blockquote></li><li><p>flex-direction方法</p><blockquote><p>flex-direction 指定了弹性子元素在父容器的位置，排列方式横向和纵向，正向和反向</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-directi<span class="symbol">on:</span> <span class="built_in">row</span> | <span class="built_in">row</span>-reverse | <span class="built_in">column</span> | <span class="built_in">column</span>-reverse</span><br></pre></td></tr></table></figure></blockquote></li><li><p>justify-content属性</p><blockquote><p>制定了 弹性子元素在行内如何对齐</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content:flex-start | flex-<span class="keyword">end</span> | center | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-<span class="keyword">around</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><p>4 .align-items属性</p><blockquote><p>align-items 设置或检索弹性盒子元素在纵轴上的对齐方式<br>值同<code>justify-content</code>类似<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span></span><br></pre></td></tr></table></figure></p></blockquote><ol><li>flex-wrap属性<blockquote><p>flex-wrap属性用于指定弹性盒子的子元素换行方式</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | <span class="type">wrap</span> | <span class="type">wrap</span>-reverse | <span class="type">initial</span> |<span class="type">inherit</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><p>各各值解析: </p><ul><li>nowrap :默认单行，子元素可能会溢出</li><li>wrap ： 多行，溢出部分放入新行，子项内部会发生断行</li></ul><ol><li>align-content属性<blockquote><p>用于修改flex-wrap属性，类似<code>align-items</code>但是它不是修改对齐，而是设置各个行的对齐</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##CSS3弹性盒子flex布局&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;弹性盒子是css3一种新的布局模式，他能更有效的对元素进行排列，对齐，分配空间。弹性盒子外和子元素内是正常渲染的，弹性盒子只定义了&lt;code&gt;弹性子元素&lt;/code&gt;如何&lt;code&gt;在弹性容器&lt;/co
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://longfeihouhouhou.github.io/tags/CSS/"/>
    
      <category term="flex" scheme="http://longfeihouhouhou.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>JS标准内置对象总结</title>
    <link href="http://longfeihouhouhou.github.io/JS%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93.md/"/>
    <id>http://longfeihouhouhou.github.io/JS标准内置对象总结.md/</id>
    <published>2017-04-02T15:24:08.000Z</published>
    <updated>2018-03-09T15:25:08.345Z</updated>
    
    <content type="html"><![CDATA[<p>##JavaScript标准内置对象</p><blockquote><p>全局属性和函数可用于所有内建的JavaScript对象</p></blockquote><p>###顶层函数（全局函数）<br>|函数            |描述                                   |<br>| ：——：   | ：——–：                       |<br>|decodeURI()|解码某个编码的URI           |</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:left">decodeURI()</td><td style="text-align:right">解码某个编码的URI</td></tr><tr><td style="text-align:left">decodeURIComponent</td><td style="text-align:right">解码一个编码的URI组件</td></tr><tr><td style="text-align:left">encodeURI()</td><td style="text-align:right">把字符串编码为URI</td></tr><tr><td style="text-align:left">endcodeURIComponent</td><td style="text-align:right">把字符串编码为URI组件</td></tr><tr><td style="text-align:left">escape()</td><td style="text-align:right">对字符串进行编码</td></tr><tr><td style="text-align:left">eval()</td><td style="text-align:right">计算JavaScript字符串，并把它作为脚本代码来执行</td></tr><tr><td style="text-align:left">getClass()</td><td style="text-align:right">返回一个JavaObject的JavaClass</td></tr><tr><td style="text-align:left">isFinite()</td><td style="text-align:right">检查某个值是否有无穷大的数</td></tr><tr><td style="text-align:left">isNaN()</td><td style="text-align:right">检查某个值是否是数字</td></tr><tr><td style="text-align:left">Number()</td><td style="text-align:right">把对象的值转为数字</td></tr><tr><td style="text-align:left">parseFloat()</td><td style="text-align:right">解析一个字符串，并返回一个浮点数</td></tr><tr><td style="text-align:left">parseInt()</td><td style="text-align:right">解析一个字符串，并返回一个整数</td></tr><tr><td style="text-align:left">String()</td><td style="text-align:right">把对象的值转换为字符串</td></tr><tr><td style="text-align:left">unescape()</td><td style="text-align:right">对由escape()编码的字符串进行解码</td></tr></tbody></table><p>###顶层属性（全局属性）<br>|方法|描述|<br>| :–|–:|<br>|Infinity|代表正的无穷大的数值。|<br>|java|代表java.*包层级的一个JavaPackage。|<br>|NaN|指示某一个只是不是数字值|<br>|Packages|根JavaPackage对象|<br>|undefined|指示未定义的值|</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##JavaScript标准内置对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全局属性和函数可用于所有内建的JavaScript对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###顶层函数（全局函数）&lt;br&gt;|函数            |描述              
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>七种布局技巧</title>
    <link href="http://longfeihouhouhou.github.io/%E4%B8%83%E7%A7%8D%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.md/"/>
    <id>http://longfeihouhouhou.github.io/七种布局技巧.md/</id>
    <published>2017-03-22T05:35:22.000Z</published>
    <updated>2018-03-19T09:42:07.567Z</updated>
    
    <content type="html"><![CDATA[<p>##面试题系列_详解CSS的七种布局技巧</p><p>@(CSS)</p><p>[TOC]</p><p>###1.流布局</p><blockquote><p>使用左右盒子浮动，给未浮动的盒子添加左右外边距，实现自适应。<br>缺点，因为使用了浮动元素，此时如果在浮动元素前添加主体内容，会使浮动另起一行，只能把主体内容放到浮动下面影响主体内容的加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   div&#123;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left,.right&#123;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: green;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line">        .center&#123;</span><br><span class="line">            margin-left: <span class="number">310</span>px;margin-right: <span class="number">310</span>px;background: plum;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div  class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;center&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>###2.BFC 布局</p><blockquote><p>BFC布局通过给两个盒子左右浮动实现侧边栏，通过overflow：hidden来实现中间盒子BFC化，原理是BFC区域不与浮动元素重合<br>缺点： 与方法一一样，主要内容区域无法最先加载，页面量大时，影响用户体验<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left,.right&#123;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-right: <span class="number">20</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: green;</span><br><span class="line">            float: right;</span><br><span class="line">            margin-left: <span class="number">20</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .center&#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            background: seagreen;</span><br><span class="line">        &#125;</span><br><span class="line">        .cc&#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div  class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;center</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"cc"</span>&gt;cc&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>###3.双飞翼布局</p><blockquote><p>这种布局是先固定好主体的位置，利用左右外边距给侧边栏预留位置，左侧边栏使用左外边距的负值—100%调到上一行，右侧边栏左外边距-宽度上跳一行。<br>具体原理以后分析<br>优点：解决主体内容不能优先加载的问题，HTML结构稍微复杂<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> .content&#123;</span><br><span class="line">          float: left;</span><br><span class="line">          width: <span class="number">100</span>%;</span><br><span class="line">      &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            margin-left: <span class="number">305</span>px;margin-right: <span class="number">305</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-left: <span class="number">-100</span>%;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">            background: palegreen;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-left: <span class="number">-300</span>px;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">            background: rebeccapurple;</span><br><span class="line">        &#125;</span><br><span class="line">        .clear:after&#123;</span><br><span class="line">            clear: both;</span><br><span class="line">            display: table;</span><br><span class="line">            content: <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      .cc&#123;</span><br><span class="line">          height: <span class="number">200</span>px;</span><br><span class="line">          background: red;</span><br><span class="line">          border: <span class="number">5</span>px solid black;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"clear"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;main&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">```    </span></span><br><span class="line"><span class="regexp">###4.圣杯布局</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&gt;和双飞翼布局类似,也实现了主体早加载,结构简单</span></span><br><span class="line"><span class="regexp">```javascript</span></span><br><span class="line"><span class="regexp"> .content&#123;</span></span><br><span class="line"><span class="regexp">            margin-left: 310px;</span></span><br><span class="line"><span class="regexp">            margin-right: 310px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .main&#123;</span></span><br><span class="line"><span class="regexp">            float: left;</span></span><br><span class="line"><span class="regexp">            width: 100%;height: 300px;</span></span><br><span class="line"><span class="regexp">            background: turquoise;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .left&#123;</span></span><br><span class="line"><span class="regexp">            float: left;</span></span><br><span class="line"><span class="regexp">            width: 300px;height: 300px;</span></span><br><span class="line"><span class="regexp">            background: purple;</span></span><br><span class="line"><span class="regexp">            margin-left: -100%;</span></span><br><span class="line"><span class="regexp">            position: relative;left: -310px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .right&#123;</span></span><br><span class="line"><span class="regexp">            float: left;</span></span><br><span class="line"><span class="regexp">            width: 300px; height: 300px;</span></span><br><span class="line"><span class="regexp">            background: cornflowerblue;</span></span><br><span class="line"><span class="regexp">            margin-left: -300px;</span></span><br><span class="line"><span class="regexp">            position: relative;left: 310px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">&lt;div class="content"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="main"&gt;main&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>###5.flex布局</p><blockquote><p>弹性布局，css3的属性方式，用了它别的真的弱爆了，而且也不用清除浮动了。但是因为是css3 需要考虑兼容性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> .content&#123;</span><br><span class="line">           display: flex;</span><br><span class="line">       &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            order: <span class="number">2</span>;</span><br><span class="line">            flex:<span class="number">1</span>;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            order: <span class="number">1</span>;</span><br><span class="line">            flex: <span class="number">0</span> <span class="number">0</span> <span class="number">300</span>px;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">            background: gray;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            order: <span class="number">3</span>;</span><br><span class="line">            flex: <span class="number">0</span> <span class="number">0</span> <span class="number">300</span>px;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">            background: purple;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;main&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="left"&gt;left&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;right&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>###6.table布局</p><blockquote><p>table布局，这个布局比flex还要简单，缺点是不能设置margin，这个缺点很致命<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> .<span class="attribute">content</span>&#123;</span><br><span class="line">           <span class="attribute">display</span>: table;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-class">.main</span>,<span class="selector-class">.left</span>,.<span class="attribute">right</span>&#123;</span><br><span class="line">           <span class="attribute">display</span>: table-cell;</span><br><span class="line">       &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            <span class="attribute">background</span>: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="attribute">left</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: gray;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="attribute">right</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: purple;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"left"</span>&gt;<span class="attribute">left</span>&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"right"</span>&gt;<span class="attribute">right</span>&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>###7.定位布局 </p><blockquote><p>定位布局，简单大方，经济实用，还能优先加载主体内容<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> .<span class="attribute">content</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">           <span class="attribute">position</span>: relative;</span><br><span class="line">       &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            <span class="attribute">background</span>: red;<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">margin-left</span>: <span class="number">310px</span>;<span class="attribute">margin-right</span>: <span class="number">310px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="attribute">left</span>&#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.right</span> &#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: purple;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"left"</span>&gt;<span class="attribute">left</span>&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"right"</span>&gt;<span class="attribute">right</span>&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##面试题系列_详解CSS的七种布局技巧&lt;/p&gt;
&lt;p&gt;@(CSS)&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;###1.流布局&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用左右盒子浮动，给未浮动的盒子添加左右外边距，实现自适应。&lt;br&gt;缺点，因为使用了浮动元素，此时如果在浮
      
    
    </summary>
    
    
      <category term="布局" scheme="http://longfeihouhouhou.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="Css" scheme="http://longfeihouhouhou.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+git搭建个人blog（下）</title>
    <link href="http://longfeihouhouhou.github.io/%E4%BD%BF%E7%94%A8hexo-git%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%EF%BC%88%E4%B8%8B%EF%BC%89.md/"/>
    <id>http://longfeihouhouhou.github.io/使用hexo-git搭建个人blog（下）.md/</id>
    <published>2017-03-15T15:34:53.000Z</published>
    <updated>2018-03-09T14:50:24.242Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程:"></a>参考教程:</h3><ul><li><p><a href="http://www.zhihu.com/question/24422335/answer/46357100" target="_blank" rel="noopener">有哪些好看的 Hexo 主题?</a></p><h3 id="1-安装主题"><a href="#1-安装主题" class="headerlink" title="1. 安装主题"></a>1. 安装主题</h3><ul><li>下载需要的 <code>theme</code> 文件包放到博客目录下的 <code>themes</code> 文件夹下<blockquote><p>为了防止出错先清除缓存</p></blockquote></li></ul><p><code></code></p><blockquote><p>启动本地 <code>localhost:4000</code> 并开启 <code>debug</code> 检测本地 blog是否启动成功</p></blockquote><p><code>hexo s -debug</code></p><h3 id="2-主题设定"><a href="#2-主题设定" class="headerlink" title="2. 主题设定"></a>2. 主题设定</h3></li></ul><ul><li>更改主目录下的_config.yml<blockquote><p>修改 deploy 值,其中 rope 修改为博客地址</p></blockquote></li></ul><h3 id="3-添加插件-sitemap-和-feed-RSS"><a href="#3-添加插件-sitemap-和-feed-RSS" class="headerlink" title="3. 添加插件 sitemap 和 feed (RSS)"></a>3. 添加插件 sitemap 和 feed (RSS)</h3><h3 id="4-添加-404-推荐使用腾讯公益-404"><a href="#4-添加-404-推荐使用腾讯公益-404" class="headerlink" title="4. 添加 404 推荐使用腾讯公益 404"></a>4. 添加 404 推荐使用腾讯公益 404</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考教程&quot;&gt;&lt;a href=&quot;#参考教程&quot; class=&quot;headerlink&quot; title=&quot;参考教程:&quot;&gt;&lt;/a&gt;参考教程:&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/question/24422335/ans
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://longfeihouhouhou.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="http://longfeihouhouhou.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo+git搭建个人blog（上）</title>
    <link href="http://longfeihouhouhou.github.io/%E4%BD%BF%E7%94%A8hexo-git%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%EF%BC%88%E4%B8%8A%EF%BC%89.md/"/>
    <id>http://longfeihouhouhou.github.io/使用hexo-git搭建个人blog（上）.md/</id>
    <published>2017-03-13T17:25:42.000Z</published>
    <updated>2018-03-09T14:50:24.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用hexo-git搭建个人blog的步骤-一-搭建篇"><a href="#使用hexo-git搭建个人blog的步骤-一-搭建篇" class="headerlink" title="使用hexo+git搭建个人blog的步骤(一) 搭建篇"></a>使用hexo+git搭建个人blog的步骤(一) 搭建篇</h1><h3 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程:"></a>参考教程:</h3><ul><li><p><a href="http://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">hexo从零开始到搭建完整</a> </p><p>###1 安装 <code>git bash</code> <code>node.js</code></p><p>###2 安装 <code>hexo</code></p><p>   npm i -g hexo<br>   hexo init<br>###3 创建 git 仓库,以用户名 + github.io 为名<br>   <img src="https://i.loli.net/2017/07/24/597578ab8cf77.png" alt="2.png"></p><p>###4 配置 GitHub 账户<br>   git config –global user.name ‘username<br>   git config –global user.email <a href="mailto:&#39;example@xx.com" target="_blank" rel="noopener">&#39;example@xx.com</a><br>###5 在 Git Bash 中创建 <code>ssh</code> </p><pre><code>ssh-keygen -t rsa -C &apos;youremail@examole.comcd ~/.sshcat id_rsa.pub</code></pre><p>###6 在 GitHub 中添加 ssh </p><blockquote><p>主页 =&gt; Settings =&gt; SSH and GPG keys =&gt; New SSH Key 添加从 gitbash 中获取到的SSH即可 titile随意</p></blockquote></li></ul><ul><li><p>验证是否成功</p><pre><code>`git bash   ssh -T git@github.com`</code></pre><p>###1.7 本地运行</p></li><li><p>修改 _config.yml 文件,添加以下字段</p><pre><code>`deploy:            type: git             repo: http: //github.com/your username/your username.gitub.io.git            branch: master`</code></pre></li><li><p>回到 git bash 中, 执行以下命令</p><pre><code>hexo cleanhexo generatehexo server </code></pre></li><li><em>注: hexo 3.0 把服务器独立成个别模块, 需要单独安装 <code>npm i hexo- server</code></em></li><li><p>打开浏览器输入: <code>localhost:4000</code> 可以看到已经在本地看到 blog 了    </p><h3 id="1-8-上传到-GitHub"><a href="#1-8-上传到-GitHub" class="headerlink" title="1.8 上传到 GitHub"></a>1.8 上传到 GitHub</h3></li><li><p>安装 <code>npm install hexo-depolyer-git --save</code> (这样能让写好的文章部署到 GitHub 服务器让别人可以浏览到)  </p></li><li><p>执行命令( 每次都按照以下步骤部署)</p><pre><code>hexo cleanhexo generatehexo deploy</code></pre></li><li><p>接下来 浏览器输入 <code>http:\\yourusername.github.io</code> 就可以看到个人博客了!</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用hexo-git搭建个人blog的步骤-一-搭建篇&quot;&gt;&lt;a href=&quot;#使用hexo-git搭建个人blog的步骤-一-搭建篇&quot; class=&quot;headerlink&quot; title=&quot;使用hexo+git搭建个人blog的步骤(一) 搭建篇&quot;&gt;&lt;/a&gt;使用he
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://longfeihouhouhou.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="http://longfeihouhouhou.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>什么是hybrid-App开发模式？</title>
    <link href="http://longfeihouhouhou.github.io/%E4%BB%80%E4%B9%88%E6%98%AFhybrid-App%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%9F.md/"/>
    <id>http://longfeihouhouhou.github.io/什么是hybrid-App开发模式？.md/</id>
    <published>2017-03-09T14:33:11.000Z</published>
    <updated>2018-03-09T14:38:21.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Native-App"><a href="#Native-App" class="headerlink" title="Native App"></a>Native App</h2><p>移动互联网刚开始兴起的时候，我们手机上的应用(App)都是通过Native App开发而成的；Native App的开发具备很多的优势：</p><p>-&gt;开发出来的产品具备良好的用户体验，动画和运行的速度非常的流畅。<br>-&gt;能够对手机的内部软件或者硬件进行直接的操作，例如：可以调取用户的通讯论、读取用户的短信(当然需要用户同意)，可以调取用户的摄像头，调取手机的重力感应等<br>…<br>但是Native App的开发也存在自己的很多不足：</p><ul><li><blockquote><p>首先是不能跨平台，针对目前最常用的IOS和安卓平台，需要用不同的技术来开发：IOS一般使用的是Object-c，而安卓平台使用的一般是Java-Native，这样就导致了开发一款App需要两队人马去做，随之而来的问题也会很多，比如：开发成本高，开发周期长，有的功能IOS有但是安卓没有(手Q就是这样的)等。</p></blockquote></li><li><blockquote><p>开发出来的产品需要用户自主性比较强：首先需要客户到应用商店安装，后期如果版本升级，用户想要看到最新的版本还需要重新的进行下载安装升级等。</p></blockquote></li><li><blockquote><p>在IOS平台上，开发出一款App上传到苹果App Store需要7天的审核期，在此期间如果审核失败，在此上传还需要七天，这样就有可能导致产品不能按时发布等。</p></blockquote></li></ul><h2 id="Web-App"><a href="#Web-App" class="headerlink" title="Web App"></a>Web App</h2><p>而HTML5的出现让Web App露出曙光。HTML5基本上不需要考虑是IOS还是安卓，两个平台一套代码基本上都是支持的；更新版本只需要在自己的服务器上更新了即可，这样用户再次访问的时候看到的就已经是最新版本的了；不需要经过漫长审核…这些优势让开发者们大为心动，但是HTML5的本质是运行在浏览器中的页面(App是直接运行在操作系统中的)，由于浏览器的差异以及对一些特殊功能支持力度的不够，导致HTML5开发存在一些局限性问题：</p><ul><li><blockquote><p>开发出来的产品性能和运行速度没有App的好，用户体验不是很好。<br>-&gt;虽然安卓和IOS平台上的浏览器大部分都是webkit内核的，但是浏览器厂商为了自己的特殊化，移动设备上的浏览器兼容也不少，甚至一些兼容问题是无法解决的(例如:position:fixed的支持非常的不好)。</p></blockquote></li><li><blockquote><p>由于HTML5的本质是运行在浏览器中的，所以想要操作系统中的软件或者硬件都需要所在的浏览器支持，很遗憾大部分浏览器对于这方面的操作都支持的不好，所以也就导致了，H5的产品在调取通讯录、摄像头、读取短信等方面存在了很大的短板，基本上很少用H5去做这些事情的。</p></blockquote></li></ul><h2 id="Hybrid-App"><a href="#Hybrid-App" class="headerlink" title="Hybrid App"></a>Hybrid App</h2><p>正是在这样是机缘巧合下，基于HTML5低成本跨平台开发优势又兼具Native App特质的Hybrid App技术杀入混战，并且很快吸引了众人的目光。Hybrid App是把Native App和Web App混合在一起的新兴模式（目前市场上的大部分App都是混合模式开发的）。利用各自的优势，去开发一款低成本、跨平台、更新快、性能好、功能丰富的App。</p><p>Hybrid App按网页语言与程序语言的混合，通常分为三种类型：多View混合型，单View混合型，Web主体型。</p><h4 id="多View混合型-目前常用的"><a href="#多View混合型-目前常用的" class="headerlink" title="多View混合型(目前常用的)"></a>多View混合型(目前常用的)</h4><p>即Native View和Web View独立展示，交替出现。2012年常见的Hybrid App是Native View与WebView交替的场景出现。这种应用混合逻辑相对简单。即在需要的时候，将WebView当成一个独立的View（Activity）运行起来，在WebView内完成相关的展示操作。这种移动应用主体通常是Native App，Web技术只是起到补充作用。开发难度和Native App基本相当。</p><h4 id="单View混合型"><a href="#单View混合型" class="headerlink" title="单View混合型"></a>单View混合型</h4><p>即在同一个View内，同时包括Native View和Web View。互相之间是覆盖（层叠）的关系。这种Hybrid App的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单View混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。</p><h4 id="Web主体型-目前比较新颖流行的方式"><a href="#Web主体型-目前比较新颖流行的方式" class="headerlink" title="Web主体型(目前比较新颖流行的方式)"></a>Web主体型(目前比较新颖流行的方式)</h4><p>即移动应用的主体是Web View，主要以网页语言编写，穿插Native功能的Hybrid App开发类型。这种类型开发的移动应用体验相对而言存在缺陷，但整体开发难度大幅降低，并且基本可以实现跨平台。通俗来说，就是App中的页面基本上都是H5完成的，我们使用一些技术框架封装一个App的壳子，框架中还提供一些操作系统级别功能的API供H5的调取，一般来说，都是由JS编写代码来完成App壳子搭建的，这样开发的App也就不会在使用JAVA或者Object-c了。</p><p>目前市面上比较流行的框架有：React Native、phoneGap、appcan、APICloud、ionicframework、appMobi、WeX5…(珠峰培训的C阶段课程会给大家讲解React Native)</p><h2 id="接下来我们分享一下，关于多View混合型中的H5和Native-App是如何的实现交互与通信的。"><a href="#接下来我们分享一下，关于多View混合型中的H5和Native-App是如何的实现交互与通信的。" class="headerlink" title="接下来我们分享一下，关于多View混合型中的H5和Native App是如何的实现交互与通信的。"></a>接下来我们分享一下，关于多View混合型中的H5和Native App是如何的实现交互与通信的。</h2><p>在这之前，我们首先需要知道，在多View混合型中，我们的HTML5页面主要运行在Native App提供的Web View中（你也可以把web view理解成为一个浏览器，因为他和浏览器基本上差不多）。但是我们知道H5是存在一些局限性的，比如我们想调取用户的摄像头拍照，这个H5解决不了，这样的话我们需要先用App把这个功能实现了，然后由H5在调取App的相关功能。这样就需要实现H5和App之间的通信交互。</p><p>####第一种常用方式：jsBridge(微信平台的JS SDK就是基于这个开发的)</p><p>WebView有一个方法，叫setWebChromeClient，可以设置WebChromeClient对象，而这个对象中有三个方法，分别是onJsAlert,onJsConfirm,onJsPrompt，当js调用window对象的对应的方法，即window.alert，window.confirm，window.prompt，WebChromeClient对象中的三个方法对应的就会被触发，利用这个机制我们就可以做一些特殊的处理。但是在项目中我们一般对于alert和confirm使用的频率较高，如果我们使用onJsAlert,onJsConfirm，那么我们普通的弹框也会受到影响，所以目前市场上最长使用的是onJsPrompt。</p><p>以上的操作基本上都需要由App那边进行开发，我们主要讲的是H5，所以此处不对App的机制做过多的描述。大家只需要知道，只要App那边做了特殊的处理（就是在webView中注入一个对象，对象中包含了我们需要调取的方法），那么在H5的js中，我们就可以调取WebView中提供的方法。一般来说需要我们给方法传递一个callback进去，这样App就会在具体的某个阶段，把我们的callback执行，从而实现对应的通信效果。下面是我们使用JS调取微信接口的DEMO：</p><ul><li><blockquote><p>首先需要引入微信提供好的一个JS：<a href="http://res.wx.qq.com/open/js/jweixin-1.0.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.0.0.js</a> (其实App就是把这个JS中提供的方法注入到了web view中，所以我们只要引入这个JS进来就可以调用App的一些方法了)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.config</span>(&#123;</span><br><span class="line">       <span class="attribute">debug</span>: false,</span><br><span class="line">       <span class="attribute">appId</span>: <span class="string">"你的AppID"</span>,</span><br><span class="line">       <span class="attribute">timestamp</span>: <span class="string">'时间戳(需要后台生成)'</span>,</span><br><span class="line">       <span class="attribute">nonceStr</span>: <span class="string">'字符串(需要后台生成)'</span>,</span><br><span class="line">       <span class="attribute">signature</span>: <span class="string">'签名(需要后台生成)'</span>,</span><br><span class="line">       <span class="attribute">jsApiList</span>: [<span class="string">'onMenuShareTimeline'</span>, <span class="string">'onMenuShareAppMessage'</span>]  <span class="comment">//功能列表，我们要使用JS-SDK的什么功能</span></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p>首先调取ready方法，这里说明一下，web view中注入的对象其实就是wx，read就是提供的一个方法，此处的匿名函数就是我们传递进去的callback，当微信检测到已经准备就绪的时候就会把我们的callback执行</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.ready</span>(function () &#123;         <span class="comment">//获取“分享到朋友圈”按钮点击状态及自定义分享内容接口</span></span><br><span class="line">            <span class="selector-tag">wx</span><span class="selector-class">.onMenuShareTimeline</span>(&#123;</span><br><span class="line">                <span class="attribute">title</span>: <span class="string">'分享标题'</span>,</span><br><span class="line">                <span class="attribute">link</span>: <span class="string">"分享的url,以http或https开头"</span>,</span><br><span class="line">                <span class="attribute">imgUrl</span>: <span class="string">"分享图标的url,以http或https开头"</span></span><br><span class="line">            &#125;);         <span class="comment">//获取“分享给朋友”按钮点击状态及自定义分享内容接口</span></span><br><span class="line">            <span class="selector-tag">wx</span><span class="selector-class">.onMenuShareAppMessage</span>(&#123;</span><br><span class="line">                <span class="attribute">title</span>: <span class="string">'分享标题'</span>,</span><br><span class="line">                <span class="attribute">desc</span>: <span class="string">"分享描述"</span>,</span><br><span class="line">                <span class="attribute">link</span>: <span class="string">"分享的url,以http或https开头"</span>,</span><br><span class="line">                <span class="attribute">imgUrl</span>: <span class="string">"分享图标的url,以http或https开头"</span>,</span><br><span class="line">                <span class="attribute">type</span>: <span class="string">'link'</span>         </span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></blockquote></li></ul><h4 id="第二种常用方式：伪装的URL或者伪装的协议"><a href="#第二种常用方式：伪装的URL或者伪装的协议" class="headerlink" title="第二种常用方式：伪装的URL或者伪装的协议"></a>第二种常用方式：伪装的URL或者伪装的协议</h4><p>相对于第一种jsBridge，第二种方式就比较的简单了。首先H5开发人员和App人员协商一套协议或者伪装的URL地址（也有可能是一放制定好，双方都按照执行即可）。然后App开发者开始实现对应的功能：第一个是实现具体业务操作的功能，例如调取摄像头拍照；第二个是劫持H5中所有发送的URL地址，然后把符合事先制定的规则的URL拦截下来，通过解析URL后面的参数值等调取对应的功能实现需求即可。下面是H5部分的代码样本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">img</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 打开摄像头拍照后执行的后续操作 img是拍下来的照片</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="built_in">window</span>.location.href=<span class="string">"zhufeng://phone?callback=fn"</span>;</span><br><span class="line"> <span class="comment">//-&gt;zhufeng:// 就是我们事先制定的一个假协议，所有这种协议的都代表需要调取App的某个功能</span></span><br><span class="line"><span class="comment">// -&gt;phone 这个标识就是事先制定的需要调取拍照功能</span></span><br><span class="line"><span class="comment">// -&gt;callback=fn 把自己JS中的某一个方法传递给App，App可以在拍照完成后执行这个方法，并且把保存的照片传递给这个方法(类似于JSONP)</span></span><br></pre></td></tr></table></figure></p><p>目前前移动市场还没有完全的成熟，技术也在不断的变革，但是我坚信HTML5和JS的市场份额会越来越大，逐渐的将会替代Native App，而是由Web App来引领移动市场的潮流…</p><p>以上文章转载自<a href="http://old.zhufengpeixun.cn/qianduanjishuziliao/CSS3heHTML5zhuanti/2016-07-15/511.html" target="_blank" rel="noopener">珠峰</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Native-App&quot;&gt;&lt;a href=&quot;#Native-App&quot; class=&quot;headerlink&quot; title=&quot;Native App&quot;&gt;&lt;/a&gt;Native App&lt;/h2&gt;&lt;p&gt;移动互联网刚开始兴起的时候，我们手机上的应用(App)都是通过Native 
      
    
    </summary>
    
    
      <category term="hybrid" scheme="http://longfeihouhouhou.github.io/tags/hybrid/"/>
    
  </entry>
  
  <entry>
    <title>解决JS阻塞特性</title>
    <link href="http://longfeihouhouhou.github.io/%E8%A7%A3%E5%86%B3JS%E9%98%BB%E5%A1%9E%E7%89%B9%E6%80%A7.md/"/>
    <id>http://longfeihouhouhou.github.io/解决JS阻塞特性.md/</id>
    <published>2017-03-01T15:27:40.000Z</published>
    <updated>2018-03-19T09:42:07.567Z</updated>
    
    <content type="html"><![CDATA[<p>##<code>JS</code>特性之阻塞</p><p>@(JavaScript)</p><blockquote><p>代码是从上到下逐行执行，<code>JS</code>有阻塞性，当浏览器解析<code>JS</code> 时候是不能干别的事情的（<code>css</code>是并行下载不会阻塞页面的其他进程），因此每当遇到script标签，页面都会等待脚本下载并执行，这会停止页面绘制，所有必要减少JS阻塞造成的困扰。</p></blockquote><p>###解决方法</p><ul><li>优化脚本位置<br>script可以方法body或者head中，浏览器在执行到body之前不会渲染页面，把js放在head中会导致延迟，虽然新一代浏览器都支持并行下载JS，但是JS下载扔会阻塞其他资源的下载（图片），因此script尽量放到body底部</li><li>减少外链脚本数量以改善性能<br>  额外的HTTP请求会带来额外的开销</li><li>使用无阻塞下载JS方法<br> 在页面加载完成之后再加载JS，即Window对象的load事件触发后再下载脚本</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;code&gt;JS&lt;/code&gt;特性之阻塞&lt;/p&gt;
&lt;p&gt;@(JavaScript)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码是从上到下逐行执行，&lt;code&gt;JS&lt;/code&gt;有阻塞性，当浏览器解析&lt;code&gt;JS&lt;/code&gt; 时候是不能干别的事情的（&lt;code&gt;c
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="http://longfeihouhouhou.github.io/%E5%9B%BE%E8%A7%A3HTTP.md/"/>
    <id>http://longfeihouhouhou.github.io/图解HTTP.md/</id>
    <published>2017-02-09T07:12:14.000Z</published>
    <updated>2018-03-19T09:42:07.519Z</updated>
    
    <content type="html"><![CDATA[<p>#图解HTTP</p><p>###HTTP 超文本传输协议<br>HTTP： HyperText Transfer Protocol </p><hr><p>一个请求从客户端到服务端的流程<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1flxr2yyvi2j20h90fkjww.jpg" alt=""><br>客户端从应用层（HTTP协议）发送一个HTTP请求。<br>接着，为了传输方便，会在传输层（TCP协议）把从应用层收到的HTTP请求报文进行分割，并在各个报文打上端口号和序号转发给网络层。<br>在网络层（IP协议），增加作为通信目的地MAC地址后转发给链路层。这样给发往网络的通信请求就齐全了。</p><blockquote><p>发送端在层与层的传递时，每经过一层都会打上该层所属的首部信息，相反，服务端在接受信息时每经过一层都会去掉该层所属的首部信息。<br>TCP/IP 协议族中IP占了一半，IP就是网络协议，IP协议的作用就是将数据包传送给对方，而为了确保准确传送，IP地址和MAC地址就是重要条件</p></blockquote><hr><p>###TCP的三次握手<br>TCP位于传输层，提供可靠的字节流服务，字节流是指为了方便传输，将大块数据分割以报文段为单位的数据包进行管理，可靠的传输服务是指TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否到达对方<br>，为了确保数据送达，TCP协议采用三次握手策略：<br>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后回复带SYN/ACK标志的数据包以示消息传达确认消息，最后发送端再传回一个带ACK标志的数据包代表握手结束</p><p>###DNS（Domian Name System）<br>域名服务系统和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问，因为与IP地址的一组纯数字相比，用字母配合数字更符合人类的记忆习惯。<br>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查找域名的服务。</p><hr><p>###各种协议与HTTP协议的关系<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly05ta14mj20cl0i2dld.jpg" alt=""></p><p>###URI与URL<br>即 统一资源标识符和统一资源定位符，URI用字符串表示某一互联网资源，而URL表示资源在互联网所处的位置。</p><p>##HTTP协议</p><ul><li>用于客户端和服务端的通信</li><li>通过请求和响应的交换达成通信<blockquote><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的</p></blockquote></li></ul><p>请求报文的构成<br> <img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly0z5ra0hj20cs06gabc.jpg" alt=""></p><hr><p> 响应报文的构成<br> <img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly129hjsjj20b305njsd.jpg" alt=""><br> HTTP协议本身不具备保存之前发送过的请求或响应的功能，使用HTTP协议本身并不保留之前一切的请求或响应报文的信息。HTTP虽然是无状态协议，但是为了实现期望的保存状态功能，于是引入了Cookie技术，有了Cookie再用HTTP协议通信，就可以管理状态了。<br> 使用URI来定位访问的资源</p><p>###HTTP方法<br>使用HTTP方法来告诉服务器意图<br>GET：获取资源<br>POST：传输实体主体<br>GET和POST使用很相似，但POST的主要目的并不是获取相应的主体内容<br>PUT：用来传输文件，因为HTTP/1.1的PUT方法自身不带验证机制，一般web网站不使用它<br>HEAD：和GET一样，但是不返回报文主体，值返回响应首部<br>DELETE ： 删除文件，同PUT相反，机制类似所以一般网站不会开放DELETE方法。<br>….<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly48gcrr0j20dz08zgmx.jpg" alt=""></p><hr><p>###TCP的持久链接<br>当一个网站需要大量请求时，会建立多次TCP，每次请求都会造成TCP的链接和断开，造成通信量的开销HTTP1.1提出HTTP keep-alive的方法，只要任意一端没有提出明显的断开，就是一直持久链接，在HTTP1.1中多有的链接都是持久链接</p><p>###Cookie的状态管理<br>HTTP是无状态协议，它不对之前发生过的请求和响应进行状态管理，无状态的优点是：由于不必保存状态，自然可以减少服务器的CPU以及内存的消耗，从侧面说正是HTTP协议本身简单才会被应用各种场景。<br>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。<br>cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在报文中加入cookie值后发送出去。<br>服务器端发现客户端发送过来的cookie后，会去检查究竟是从哪一个客户端发来的链接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#图解HTTP&lt;/p&gt;
&lt;p&gt;###HTTP 超文本传输协议&lt;br&gt;HTTP： HyperText Transfer Protocol &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个请求从客户端到服务端的流程&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://longfeihouhouhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>简单总结js的设计模式</title>
    <link href="http://longfeihouhouhou.github.io/%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93js%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md/"/>
    <id>http://longfeihouhouhou.github.io/简单总结js的设计模式.md/</id>
    <published>2017-02-04T10:28:55.000Z</published>
    <updated>2018-03-19T09:45:36.220Z</updated>
    
    <content type="html"><![CDATA[<p>##简单总结JS设计模式</p><p>[toc]</p><p>##工厂模式</p><blockquote><p>目的：解决多个类似对象声明的问题，也就是解决实例化对象产生重复的问题，把实现同一件事情的相同代码放在一个函数中，以后想要使用，不用重新编写，只要函数执行。也叫“函数的封装”<br>优点：能解决多个相似的问题，减少代码量，提高代码利用率<br>缺点：</p></blockquote><p>##单例模式</p><blockquote><p>用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。<br>优点：</p><ol><li>可以用来划分命名空间，减少全局变量的数量；</li><li>使用单例模式可以使代码清晰，容易阅读和维护。</li><li>可以被实例化，切可以被实例化一次</li></ol></blockquote><p>##原型模式</p><blockquote></blockquote><p>##观察者模式</p><blockquote></blockquote><p>##</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##简单总结JS设计模式&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;##工厂模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目的：解决多个类似对象声明的问题，也就是解决实例化对象产生重复的问题，把实现同一件事情的相同代码放在一个函数中，以后想要使用，不用重新编写，只要函数执行。
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Css特性</title>
    <link href="http://longfeihouhouhou.github.io/Css%E7%89%B9%E6%80%A7.md/"/>
    <id>http://longfeihouhouhou.github.io/Css特性.md/</id>
    <published>2017-02-04T03:31:43.000Z</published>
    <updated>2018-03-19T09:42:07.455Z</updated>
    
    <content type="html"><![CDATA[<p>元素左右居中</p><ul><li><ol><li>内联元素: text-align:centerte</li></ol></li><li><ol><li>定宽块级元素：margin: 0 auto</li></ol></li><li><ol><li>不定宽块级元素：<ul><li>a.  元素外面加入完整的table标签（table,tbody,tr,td）在td内设置margin的值为auto</li><li>b. 使用display:inline-block 再 text-align</li><li>c. 增加一个父级盒子 给父级盒子设置向左浮动，相对定位，left：50%  ，给子盒子相对定位，left值为-50%</li><li>d. 利用transform中的translateX属性，设置绝对定位，left：50%在translateX（-50%）<br>##元素垂直居中</li></ul></li></ol></li><li><ol><li>父元素高度确定的单行文本：设置父元素的height和line-height</li></ol></li><li><ol><li>父元素高度确定的多行文本：<br>   a:  插入table，设置vertical-align：middle<br>   b: 先设置display：table-cell 在设置verticala-align：middle</li></ol></li><li><ol><li>flex布局解决方法：<br>display:flex<br>align-items:center;<br>##解决img标签间隙问题</li></ol></li><li><ol><li>给父元素设置font-size: 0</li></ol></li><li><ol><li>设置display：block</li></ol></li><li><ol><li>设置图片margin为负值<br>##浮动<blockquote><p> 定义：浮动元素会脱离文档流向左/右浮动，直到碰到父元素或者其他浮动元素，值得注意的是当同时有多个浮动元素，大小不一致的情况下可能会导致“卡住”</p></blockquote>###浮动元素会导致父级元素高度坍塌<blockquote><p>浮动元素脱离文档流，如果父级盒子没设置高度，而是靠子级撑开的话，会导致没了高度</p></blockquote>###清除浮动<blockquote><p>清除浮动主要方法是clear和BFC</p></blockquote></li></ol></li><li>clear属性不允许被清除浮动元素的左边/右边挨着浮动元素，底层原理是在被清除浮动元素上边或者下边添加足够的清除空间。<br>给浮动元素父元素加一个after伪类，表示加载完后在内容里面追加。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:table;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果需要兼容IE6/7的话需要给父元素一个<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.clearfix&#123;</span></span><br><span class="line"><span class="code">*zoom:1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>BFC以后再总结，目前clear就够了</p></blockquote><p>###图片在div中，div下面会有4像素的空白</p><blockquote><p>方法： 给图片display block 或者 table  还有就是margin…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;元素左右居中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;内联元素: text-align:centerte&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;定宽块级元素：margin: 0 auto&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="布局" scheme="http://longfeihouhouhou.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
      <category term="Css" scheme="http://longfeihouhouhou.github.io/tags/Css/"/>
    
  </entry>
  
</feed>
