<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LoongFly的博客</title>
  <icon>https://www.gravatar.com/avatar/99179de3d0b7799ea71b65793bf56687</icon>
  <subtitle>天生竞争者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://longfeihouhouhou.github.io/"/>
  <updated>2018-03-09T15:40:41.032Z</updated>
  <id>http://longfeihouhouhou.github.io/</id>
  
  <author>
    <name>LoongFly</name>
    <email>695409705@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>html5的web语义化</title>
    <link href="http://longfeihouhouhou.github.io/html5%E7%9A%84web%E8%AF%AD%E4%B9%89%E5%8C%96.md/"/>
    <id>http://longfeihouhouhou.github.io/html5的web语义化.md/</id>
    <published>2018-03-09T15:39:59.000Z</published>
    <updated>2018-03-09T15:40:41.032Z</updated>
    
    <content type="html"><![CDATA[<p>##<code>Web</code>语义化<br>[toc]</p><blockquote><p>通俗讲<code>web语义化</code>就是合适的标签干合适的事儿，其优点在于标签语义化有助于构架良好的<code>html</code>结构，构建清晰的结构，便于开发、维护。有利于<code>搜索引擎</code>的<code>建立索引</code>、<code>抓取</code>；同样有利于页面在<code>不同的设备</code>上显示尽可能相同；</p><ul><li><ol><li>有利于搜索</li></ol></li><li><ol><li>容易兼容不同设备</li></ol></li><li><ol><li>结构清晰，便于开发、维护。</li></ol></li></ul></blockquote><p>##如何构建web语义化的页面？</p><ul><li><p><code>h1</code>-<code>h6</code>的规划</p><blockquote><p>一篇文章应该只有一个总标题<code>h1</code>,然后根据文章的具体内容，若干个<code>h2</code>及嵌套的<code>h3</code>…</p></blockquote></li><li><p><code>p</code>标签的使用</p><blockquote><p>每一个段落都应该用<code>p</code>去表示，默认情况下<code>p</code>是有一定的缩进及行距。如果不想这样排版，应该另外写<code>css</code>去控制</p></blockquote></li><li><p><code>ul</code>、<code>ol</code>、<code>li</code>的使用</p><blockquote><p>li必须是在ul或者ol里面，当我们只是列举一些数据，但又达不到一个分论点这种语义时，或者在一些咨询的网站新闻列表中，都应该用此语义标签。</p></blockquote></li><li><p><code>header</code>、<code>nav</code>、<code>article</code>、<code>section</code>、<code>aside</code>、<code>footer</code>标签的关系<br><img src="http://images.cnitblog.com/i/84053/201403/072109412842073.jpg" alt="明细内容页的语义化"></p></li><li><p><code>th</code>、<code>tbody</code></p><blockquote><p>表格的表头及重复列表内容，正常的表格都应该区分表头及表体内容。表头默认是加粗并且居中的。</p></blockquote></li><li><p><code>address</code></p><blockquote><p>表示联系方式，方便爬虫立马找到你的联系方式。<br>其他的不常见，就不列举了</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;code&gt;Web&lt;/code&gt;语义化&lt;br&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通俗讲&lt;code&gt;web语义化&lt;/code&gt;就是合适的标签干合适的事儿，其优点在于标签语义化有助于构架良好的&lt;code&gt;html&lt;/code&gt;结构，构建清晰的结构，便于开发
      
    
    </summary>
    
    
      <category term="html" scheme="http://longfeihouhouhou.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>总结JS中MAth方法</title>
    <link href="http://longfeihouhouhou.github.io/%E6%80%BB%E7%BB%93JS%E4%B8%ADMAth%E6%96%B9%E6%B3%95.md/"/>
    <id>http://longfeihouhouhou.github.io/总结JS中MAth方法.md/</id>
    <published>2018-03-09T15:38:59.000Z</published>
    <updated>2018-03-09T15:39:20.486Z</updated>
    
    <content type="html"><![CDATA[<p>##Math<br><code>Math</code>是一个内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。</p><p>###属性<br><code>Math.E</code><br>欧拉常数，也是自然对数的底数, 约等于 2.718.<br><code>Math.LN2</code><br>2的自然对数, 约等于0.693.<br><code>Math.LN10</code><br>10的自然对数, 约等于 2.303.<br><code>Math.LOG2E</code><br>以2为底E的对数, 约等于 1.443.<br><code>Math.LOG10E</code><br>以10为底E的对数, 约等于 0.434.<br><code>Math.PI</code><br>圆周率，一个圆的周长和直径之比，约等于 3.14159.<br><code>Math.SQRT1_2</code><br>1/2的平方根, 约等于 0.707.<br><code>Math.SQRT2</code><br>2的平方根,约等于 1.414.</p><p>###方法<br>Math.abs(x)<br>返回绝对值<br>Math.acos(x)<br>返回x的反余弦值<br>Math.acosh(x)<br>返回X的反双曲余弦值<br>Math.asin(x)<br>返回x的反正弦值<br>Math.asinin(x)<br>返回反双正弦<br>Math.atan(x)<br>返回反正切<br>Math.atanh(x)<br>返回反双正切<br>Math.tan2(y,x)<br>…<br><code>Math.floor(x)</code><br>返回小于x的最大整数，也就是向下取整<br><code>Math.fround(x)</code><br>返回大于x的最小整数，也就是向上取整<br><code>Math.max([x[,y],...])</code><br>返回0到多个数值中的最大值<br><code>Math.min([x[,y],...])</code><br>返回0到多个数值中的最小值<br> <code>Math.random()</code><br> 返回0-1之间的伪随机数<br> <code>Math.round()</code><br> 四舍五入的整数<br> <code>Math.trunc(x)</code><br> 舍去小数。<br> <code>Math.sign(x)</code><br> 返回四种数值<code>0</code>,<code>1</code>,<code>1</code>,<code>NaN</code>分别代表着<strong>正零，整数，负数，NaN</strong><br> 此处加深记忆，可以转化为false的五种值<br><code>0</code>,<code>&quot;&quot;</code>,<code>null</code>,<code>undefiend</code>,<code>false</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##Math&lt;br&gt;&lt;code&gt;Math&lt;/code&gt;是一个内置对象，它具有数学常数和函数的属性和方法。不是一个函数对象。&lt;/p&gt;
&lt;p&gt;###属性&lt;br&gt;&lt;code&gt;Math.E&lt;/code&gt;&lt;br&gt;欧拉常数，也是自然对数的底数, 约等于 2.718.&lt;br&gt;&lt;code&gt;
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
      <category term="Math" scheme="http://longfeihouhouhou.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>总结JS数组的30种方法</title>
    <link href="http://longfeihouhouhou.github.io/%E6%80%BB%E7%BB%93JS%E6%95%B0%E7%BB%84%E7%9A%8430%E7%A7%8D%E6%96%B9%E6%B3%95.md/"/>
    <id>http://longfeihouhouhou.github.io/总结JS数组的30种方法.md/</id>
    <published>2018-03-09T15:37:53.000Z</published>
    <updated>2018-03-09T15:38:26.631Z</updated>
    
    <content type="html"><![CDATA[<p>##数组Array的方法<br>[toc]</p><h3 id="1-concat方法"><a href="#1-concat方法" class="headerlink" title="1 concat方法"></a>1 <code>concat</code>方法</h3><blockquote><p>链接两个数组，返回一个新数组。不改变原有数组<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">var arr2=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>];</span><br><span class="line">   var f=arr1.concat(arr2);</span><br><span class="line">   console.log(f);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-copyWithin"><a href="#2-copyWithin" class="headerlink" title="2 copyWithin"></a>2 <code>copyWithin</code></h3><blockquote><p>方法有三个参数(target,start,end);在索引为target的位置开始复制从start索引，到end索引的项，改变数组。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">var arr2=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>];</span><br><span class="line">arr1.copyWithin(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">   [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3-entries-方法"><a href="#3-entries-方法" class="headerlink" title="3 entries() 方法"></a>3 <code>entries()</code> 方法</h3><blockquote><p>返回一个新的Array lterator对象，该对象包含数组中每个索引的键/值对。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">   var arr2=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>];</span><br><span class="line">var f= arr1.entries();</span><br><span class="line">for(var <span class="type">key</span> of f)&#123;</span><br><span class="line">console.log(<span class="type">key</span>)</span><br><span class="line">&#125;</span><br><span class="line">   [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">   [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">   [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">   [<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="4-every-方法"><a href="#4-every-方法" class="headerlink" title="4 every()方法"></a>4 <code>every()</code>方法</h3><blockquote><p>测试数组的所有元素是否都通过了 指定函数的测试</p></blockquote><p>####语法</p><blockquote><p>arr.every(callback)</p></blockquote><p> every方法为数组中每个元素执行一次callback函数，直到它找到一个使callback返回false的元素，callback被调用时传入三个参数，元素值，元素的索引，原数组。every调用回调函数会返回一个布尔值类型，作为遍历的最终结果。如果fasle那么没有都通过。</p><p>例如:检测数组是否都大于10.<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBig</span><span class="params">(element,index,array)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> (element&gt;=<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">20</span>,<span class="number">22</span>];</span><br><span class="line"><span class="keyword">var</span> f=arr.every(isBig);</span><br><span class="line">f   <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p><p>###5 <code>fill()</code></p><blockquote><p>方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。<br>三个参数  value(用来填充的值), start(开始索引) ,end(结束索引，不包括最后一项)  改变原有数组</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">arr1.fill(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>###6 <code>filter()</code></p><blockquote><p>方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 <em>过滤器记得了吗？</em><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function isBig(element,index,array)&#123;</span><br><span class="line"> return (element&gt;=<span class="number">10</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> var arr=[<span class="number">1</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">20</span>,<span class="number">22</span>];</span><br><span class="line"> var f= arr.filter(isbig);</span><br><span class="line"> f   [<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">20</span>,<span class="number">22</span>]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>和every类似，只不过every方法返回的是布尔值，而filter则是调用回调函数，true就留下ele，false就不保留。同样不改变原数组。</p></blockquote><p>###7 <code>find()</code></p><blockquote><p>方法返回数组中满足提供的测试函数的第一个元素的值。否则返回<code>undefiend</code>。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function isBigEnough(element) &#123;</span><br><span class="line">  return element &gt;= <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].find(isBigEnough); <span class="comment">// 130</span></span><br></pre></td></tr></table></figure></p></blockquote><p>例如，在所提供的数字对象中查找。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var inventory = [</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'apples'</span>, <span class="string">quantity:</span> <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'bananas'</span>, <span class="string">quantity:</span> <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'cherries'</span>, <span class="string">quantity:</span> <span class="number">5</span>&#125;</span><br><span class="line">];</span><br><span class="line">function  findApple(fruit)&#123;</span><br><span class="line"><span class="keyword">return</span> (fruit.name==<span class="string">'apple'</span>)</span><br><span class="line">&#125;</span><br><span class="line">var f= inventory.find(findApple)</span><br><span class="line"><span class="comment">//f  &#123;name: "apples", quantity: 2&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="8-findIndex"><a href="#8-findIndex" class="headerlink" title="8 findIndex()"></a>8 <code>findIndex()</code></h3><blockquote><p>方法和<code>find()</code>方法类似，只是返回值不一样，返回的是那一项的索引。</p></blockquote><p>####语法</p><blockquote><p>arr.findIndex(callback[, thisArg])      </p></blockquote><h3 id="9-forEach"><a href="#9-forEach" class="headerlink" title="9 forEach()"></a>9 <code>forEach()</code></h3><blockquote><p>方法对数组的每个元素执行一次提供的函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(item,index)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>callback 提供三个参数 item, index,array(当前操作的数组)<br>array.forEach(callback[,   thisArg])</p></blockquote><p>###10 <code>includes()</code></p><blockquote><p>方法用来判断一个数组是否包含一个指定的值，如果是，返回布尔值。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.includes(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// true;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>###语法</p><blockquote><p>arr.includes(searchElement,fromIndex)</p></blockquote><p>###11 <code>indexof()</code>方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，返回-1.<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a= [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">a.indexOf(<span class="number">2</span>);<span class="comment">// 0</span></span><br><span class="line">a.indexOf(<span class="number">7</span>); <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>####语法</p><blockquote><p>arr.indexOf(serchElement [, formIndex = 0])</p></blockquote><h3 id="12-join"><a href="#12-join" class="headerlink" title="12 join()"></a>12 <code>join()</code></h3><blockquote><p>方法将数组（或一个类数组对象）的所有元素链接到一个字符串中。不会改变原数组。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a=[<span class="string">'wind'</span>,<span class="string">'rain'</span>,<span class="string">'fire'</span>];</span><br><span class="line">a.join();</span><br><span class="line"><span class="regexp">//</span><span class="string">'wind,rain,fire'</span> 默认<span class="string">','</span>分隔;</span><br><span class="line">a.join(<span class="string">""</span>)</span><br><span class="line"><span class="regexp">//</span><span class="string">'windrainfire'</span> <span class="regexp">//</span>没有分隔符</span><br><span class="line"><span class="regexp">//</span>其他分隔符  <span class="string">'+'</span>  <span class="string">'-'</span> 等等这种写法。</span><br></pre></td></tr></table></figure></p></blockquote><p>####语法</p><blockquote><p>arr.join( separator )  //separator 指定一个字符串来分隔数组的每个元素，如果需要，将分隔符转换成字符串，如果省略分隔符(“”)，默认()”,”。<br>返回值是一个所有数组链接的字符串</p></blockquote><h3 id="13-keys"><a href="#13-keys" class="headerlink" title="13 keys()"></a>13 <code>keys()</code></h3><blockquote><p>方法返回一个新的Array迭代器。它包含数组中每个索引的键。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var arr</span>=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="attribute">var f</span> = arr.keys();</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>暂时没看到用处，先不看。</p></blockquote><h3 id="14-lastIndexOf"><a href="#14-lastIndexOf" class="headerlink" title="14 lastIndexOf()"></a>14 <code>lastIndexOf()</code></h3><blockquote><p>方法返回指定元素在数组中的最后一个索引，如果不存在则返回-1。<br>arr.lastIndexOf( searchElement[, fromIndex = arr.length-1]);<br>fromIndex代表逆向查找，即从这个索引处向前查找，而忽略这个索引后面的项。在具体操作中这个fromIndex可以用来优化。当值为负数，且绝对值大于数组长度返回-1。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">11</span>];</span><br><span class="line">arr1.lastIndexOf(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">arr1.lastIndexOf(<span class="number">11</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p></blockquote><p>###15 <code>map()</code></p><blockquote><p>方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。不改变原数组。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">var doubles = numbers.map(x=&gt;x**<span class="number">2</span>);</span><br><span class="line"><span class="comment">// doubles [1,25,100,225];</span></span><br></pre></td></tr></table></figure></p></blockquote><p>####语法</p><blockquote><p>arr.map(callback(currentValue , index , array)[, thisArg]);<br>返回一个新数组，每个元素都是回调函数的结果。</p></blockquote><p>例子：求一个数组的平方根<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers=[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> f = numners.<span class="keyword">map</span>(Math.sqrt);</span><br><span class="line"><span class="comment">// f [1,2,3];</span></span><br></pre></td></tr></table></figure></p><blockquote><p>很难理解Math.sqrt方法怎么不用输入值就能运算了，而且Math.sqrt方法不能计算数组，它是一个数学方法。根据结果推导答案应该是：numbers数组，执行map方法，会让数组的每一项都进行callback函数的执行，最后将所有返回结果当成数组的项来组成一个新的数组。这也就符合MDN上的官方解释了^_^。</p></blockquote><p>###16  <code>pop()</code></p><blockquote><p>无需多说，删除数组的最后一项，是对数组进行的操作，所以改变原数组。返回被删除的项，值得注意的是返回的并不是数组项，而是一个单纯的元素。</p></blockquote><p>###17 <code>push()</code></p><blockquote><p>追加一个或<code>多个</code>元素到末尾。返回的是新的数组长度。</p></blockquote><h3 id="18-reduce"><a href="#18-reduce" class="headerlink" title="18 reduce()"></a>18 <code>reduce()</code></h3><blockquote><p>方法对累加器和数组中的每个元素(从左到右)应用一个函数，将其减少为单个值。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span><span class="params">(sum,value)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum + value;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//  这里reduce的第二个参数就是初始值，没有初始值默认项的第一个</span></span><br><span class="line"><span class="comment">// total 6</span></span><br></pre></td></tr></table></figure></p></blockquote><p>####语法</p><blockquote><p>arr.reduce(callback[, initialValue])<br>callback 执行数组中每个值得函数，包含四个参数：</p><ul><li><blockquote><p><code>accumulator</code>：累加器累加回调的返回值；它是上一次调用回调时返回的积累值，或inittialValue</p></blockquote></li><li><blockquote><p><code>currentValue</code>： 数组中正在处理的元素</p></blockquote></li><li><blockquote><p><code>currentIndex</code>： 数组中正在处理元素的索引</p></blockquote></li><li><blockquote><p><code>array</code><br>initialValue 用作第一个调用callback的第一个参数的值，如果没有提供出始值，则使用数组的第一个元素。</p></blockquote></li></ul></blockquote><h3 id="19-reduceRight"><a href="#19-reduceRight" class="headerlink" title="19 reduceRight()"></a>19 <code>reduceRight()</code></h3><blockquote><p>方法接受一个函数作为累加器，和数组的每个值(从右到左)将其减少为单个值。与reduce的执行方向相反。</p></blockquote><h3 id="20-revese"><a href="#20-revese" class="headerlink" title="20 revese()"></a>20 <code>revese()</code></h3><blockquote><p>方法将数组中元素的位置颠倒</p></blockquote><p>####语法</p><blockquote><p>arr.reverse()  无参数。。</p></blockquote><h3 id="21-shift"><a href="#21-shift" class="headerlink" title="21 shift()"></a>21 <code>shift()</code></h3><blockquote><p>方法从数组删除第一个元素，返回删除的元素值。更改数组的长度。无参数</p></blockquote><h3 id="22-slice"><a href="#22-slice" class="headerlink" title="22 slice()"></a>22 <code>slice()</code></h3><blockquote><p>该方法返回一个从开始到结束选择的数组的一部分浅拷贝到一个新数组对象，原数组不会被修改</p></blockquote><p>####语法</p><blockquote><p>arr.slice(begin,end) 包含开头不包含结尾，默认全(0,arr.lenth);</p></blockquote><h3 id="23-some"><a href="#23-some" class="headerlink" title="23 some()"></a>23 <code>some()</code></h3><blockquote><p>方法测试数组中的某些元素是否通过由提供的函数实现的测试。返回布尔值。<br>例子：用来测试数组总是否有元素大于10<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBig</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (element&gt;=<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">number</span>= [<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">11</span>];</span><br><span class="line"><span class="keyword">var</span> f=<span class="built_in">number</span>.some(isBig)</span><br><span class="line"><span class="comment">// f true;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="24-sort"><a href="#24-sort" class="headerlink" title="24 sort()"></a>24 <code>sort()</code></h3><blockquote><p>方法在适当的位置对数组的元素进行排序，并返回数组。sort排序不一定是稳定的。默认排序书序是根据字符串Unicode码点。</p></blockquote><h3 id="25-splice"><a href="#25-splice" class="headerlink" title="25 splice()"></a>25 <code>splice()</code></h3><blockquote><p>方法通过删除现有元素和/或添加新元素来更改一个数组的内容。返回被删除的元素的<code>数组</code></p></blockquote><p>####语法</p><blockquote><p>array.splice(start);  删除从start 到end<br>array.splice(start,deletCount)<br>array.splice(start,deletCount,item1,item2,….) </p></blockquote><p>####参数</p><blockquote><p>start 指定修改的开始位置，如果超出了数组的长度，则从数组末尾开始添加内容。如果负数，则从末尾第几位计数。<br>deletCount表示删除元素的个数，如果是0表示不移除。<br>item1,item2 …要添加进数组的元素。</p></blockquote><h3 id="26-toLocaleString"><a href="#26-toLocaleString" class="headerlink" title="26 toLocaleString()"></a>26 <code>toLocaleString()</code></h3><blockquote><p>返回一个字符串表示数组中的元素，数组中的各个元素将使用各自的toLocaleString方法转化成字符串<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr1= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">var f=arr1.toLocaleString();</span><br><span class="line"><span class="comment">//f "1,2,3,4,5,6,7,8,9"</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="27-toSource"><a href="#27-toSource" class="headerlink" title="27 toSource()"></a>27 <code>toSource()</code></h3><blockquote><p>返回一个字符串，代表该数组的源代码。  改代码非标准，不要在生产环境使用。<em>似乎在js中删除了这个方法</em> 可以忽略了</p></blockquote><h3 id="28-toString"><a href="#28-toString" class="headerlink" title="28 toString()"></a>28 <code>toString()</code></h3><blockquote><p>返回一个字符串，表示指定的数组及其元素 。暂时不知道与toLocaleString的区别。</p></blockquote><h3 id="29-unshift"><a href="#29-unshift" class="headerlink" title="29 unshift()"></a>29 <code>unshift()</code></h3><blockquote><p>话不多说，开头添加，返回数组新长度。</p></blockquote><h3 id="30-values"><a href="#30-values" class="headerlink" title="30 values()"></a>30 <code>values()</code></h3><blockquote><p>方法返回一个行的Array Iterator对象，该对象包含数组每个索引的值。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'w'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>];</span><br><span class="line"><span class="keyword">let</span> eArr = arr.values();</span><br><span class="line">// 您的浏览器必须支持 <span class="keyword">for</span>..<span class="keyword">of</span> 循环</span><br><span class="line">// 以及 <span class="keyword">let</span> —— 将变量作用域限定在 <span class="keyword">for</span> 循环中</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> letter <span class="keyword">of</span> eArr) &#123;</span><br><span class="line">  console.log(letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>以上30个方法总结完毕！！！！！！累啊</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##数组Array的方法&lt;br&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;1-concat方法&quot;&gt;&lt;a href=&quot;#1-concat方法&quot; class=&quot;headerlink&quot; title=&quot;1 concat方法&quot;&gt;&lt;/a&gt;1 &lt;code&gt;concat&lt;/code&gt;方法&lt;/h3
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
      <category term="Array" scheme="http://longfeihouhouhou.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>七种布局技巧</title>
    <link href="http://longfeihouhouhou.github.io/%E4%B8%83%E7%A7%8D%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.md/"/>
    <id>http://longfeihouhouhou.github.io/七种布局技巧.md/</id>
    <published>2018-03-09T15:35:22.000Z</published>
    <updated>2018-03-09T15:36:49.518Z</updated>
    
    <content type="html"><![CDATA[<p>##面试题系列_详解CSS的七种布局技巧</p><p>@(CSS)</p><p>[TOC]</p><p>###1.流布局</p><blockquote><p>使用左右盒子浮动，给未浮动的盒子添加左右外边距，实现自适应。<br>缺点，因为使用了浮动元素，此时如果在浮动元素前添加主体内容，会使浮动另起一行，只能把主体内容放到浮动下面影响主体内容的加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   div&#123;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left,.right&#123;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: green;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line">        .center&#123;</span><br><span class="line">            margin-left: <span class="number">310</span>px;margin-right: <span class="number">310</span>px;background: plum;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div  class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;center&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>###2.BFC 布局</p><blockquote><p>BFC布局通过给两个盒子左右浮动实现侧边栏，通过overflow：hidden来实现中间盒子BFC化，原理是BFC区域不与浮动元素重合<br>缺点： 与方法一一样，主要内容区域无法最先加载，页面量大时，影响用户体验<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left,.right&#123;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            background: red;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-right: <span class="number">20</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            background: green;</span><br><span class="line">            float: right;</span><br><span class="line">            margin-left: <span class="number">20</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .center&#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            background: seagreen;</span><br><span class="line">        &#125;</span><br><span class="line">        .cc&#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div  class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"center"</span>&gt;center</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"cc"</span>&gt;cc&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>###3.双飞翼布局</p><blockquote><p>这种布局是先固定好主体的位置，利用左右外边距给侧边栏预留位置，左侧边栏使用左外边距的负值—100%调到上一行，右侧边栏左外边距-宽度上跳一行。<br>具体原理以后分析<br>优点：解决主体内容不能优先加载的问题，HTML结构稍微复杂<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> .content&#123;</span><br><span class="line">          float: left;</span><br><span class="line">          width: <span class="number">100</span>%;</span><br><span class="line">      &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            margin-left: <span class="number">305</span>px;margin-right: <span class="number">305</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-left: <span class="number">-100</span>%;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">            background: palegreen;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-left: <span class="number">-300</span>px;</span><br><span class="line">            width: <span class="number">300</span>px;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">            background: rebeccapurple;</span><br><span class="line">        &#125;</span><br><span class="line">        .clear:after&#123;</span><br><span class="line">            clear: both;</span><br><span class="line">            display: table;</span><br><span class="line">            content: <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      .cc&#123;</span><br><span class="line">          height: <span class="number">200</span>px;</span><br><span class="line">          background: red;</span><br><span class="line">          border: <span class="number">5</span>px solid black;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"clear"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;main&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">```    </span></span><br><span class="line"><span class="regexp">###4.圣杯布局</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&gt;和双飞翼布局类似,也实现了主体早加载,结构简单</span></span><br><span class="line"><span class="regexp">```javascript</span></span><br><span class="line"><span class="regexp"> .content&#123;</span></span><br><span class="line"><span class="regexp">            margin-left: 310px;</span></span><br><span class="line"><span class="regexp">            margin-right: 310px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .main&#123;</span></span><br><span class="line"><span class="regexp">            float: left;</span></span><br><span class="line"><span class="regexp">            width: 100%;height: 300px;</span></span><br><span class="line"><span class="regexp">            background: turquoise;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .left&#123;</span></span><br><span class="line"><span class="regexp">            float: left;</span></span><br><span class="line"><span class="regexp">            width: 300px;height: 300px;</span></span><br><span class="line"><span class="regexp">            background: purple;</span></span><br><span class="line"><span class="regexp">            margin-left: -100%;</span></span><br><span class="line"><span class="regexp">            position: relative;left: -310px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        .right&#123;</span></span><br><span class="line"><span class="regexp">            float: left;</span></span><br><span class="line"><span class="regexp">            width: 300px; height: 300px;</span></span><br><span class="line"><span class="regexp">            background: cornflowerblue;</span></span><br><span class="line"><span class="regexp">            margin-left: -300px;</span></span><br><span class="line"><span class="regexp">            position: relative;left: 310px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">&lt;div class="content"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="main"&gt;main&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"left"</span>&gt;left&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="right"&gt;right&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p>###5.flex布局</p><blockquote><p>弹性布局，css3的属性方式，用了它别的真的弱爆了，而且也不用清除浮动了。但是因为是css3 需要考虑兼容性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> .content&#123;</span><br><span class="line">           display: flex;</span><br><span class="line">       &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            order: <span class="number">2</span>;</span><br><span class="line">            flex:<span class="number">1</span>;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .left&#123;</span><br><span class="line">            order: <span class="number">1</span>;</span><br><span class="line">            flex: <span class="number">0</span> <span class="number">0</span> <span class="number">300</span>px;</span><br><span class="line">            height:<span class="number">300</span>px;</span><br><span class="line">            background: gray;</span><br><span class="line">        &#125;</span><br><span class="line">        .right&#123;</span><br><span class="line">            order: <span class="number">3</span>;</span><br><span class="line">            flex: <span class="number">0</span> <span class="number">0</span> <span class="number">300</span>px;</span><br><span class="line">            height: <span class="number">300</span>px;</span><br><span class="line">            background: purple;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;main&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="left"&gt;left&lt;/</span>div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"right"</span>&gt;right&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>###6.table布局</p><blockquote><p>table布局，这个布局比flex还要简单，缺点是不能设置margin，这个缺点很致命<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> .<span class="attribute">content</span>&#123;</span><br><span class="line">           <span class="attribute">display</span>: table;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-class">.main</span>,<span class="selector-class">.left</span>,.<span class="attribute">right</span>&#123;</span><br><span class="line">           <span class="attribute">display</span>: table-cell;</span><br><span class="line">       &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            <span class="attribute">background</span>: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="attribute">left</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: gray;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="attribute">right</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: purple;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"left"</span>&gt;<span class="attribute">left</span>&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"right"</span>&gt;<span class="attribute">right</span>&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>###7.定位布局 </p><blockquote><p>定位布局，简单大方，经济实用，还能优先加载主体内容<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> .<span class="attribute">content</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">           <span class="attribute">position</span>: relative;</span><br><span class="line">       &#125;</span><br><span class="line">        .main&#123;</span><br><span class="line">            <span class="attribute">background</span>: red;<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">margin-left</span>: <span class="number">310px</span>;<span class="attribute">margin-right</span>: <span class="number">310px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .<span class="attribute">left</span>&#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.right</span> &#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background</span>: purple;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">"content"</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"main"</span>&gt;main&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"left"</span>&gt;<span class="attribute">left</span>&lt;/div&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"right"</span>&gt;<span class="attribute">right</span>&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##面试题系列_详解CSS的七种布局技巧&lt;/p&gt;
&lt;p&gt;@(CSS)&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;###1.流布局&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用左右盒子浮动，给未浮动的盒子添加左右外边距，实现自适应。&lt;br&gt;缺点，因为使用了浮动元素，此时如果在浮
      
    
    </summary>
    
    
      <category term="Css" scheme="http://longfeihouhouhou.github.io/tags/Css/"/>
    
      <category term="布局" scheme="http://longfeihouhouhou.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>怪异模式</title>
    <link href="http://longfeihouhouhou.github.io/%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F.md/"/>
    <id>http://longfeihouhouhou.github.io/怪异模式.md/</id>
    <published>2018-03-09T15:33:55.000Z</published>
    <updated>2018-03-09T15:34:42.461Z</updated>
    
    <content type="html"><![CDATA[<p>CSS盒子模型<br>一个盒子模型是由长宽，边框，内填充，外边距构成的如下图<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fm11r9p5dij205j05bglh.jpg" alt=""><br>可以知道总元素的实际宽度应该是：<br>宽度+左右外边距+左右内填充+左右边框，高度同理</p><p>##怪异模式</p><p>@(CSS)</p><p>怪异模式：也叫兼容模式，服务于旧规则，在早期浏览器实现css机制时，浏览器并没有遵循当时的标准，导致网页开发者不得不依据各个浏览器的规范来使用css导致大部分网站的css不符合标准，但是现在标准一致性越来越重要，如果遵循标准会产生问题，忽略标准又会维持浏览器大战时期的混乱，这就是怪异模式<br>解决方案：<br>所有的浏览器提供两种模式兼容和标准，而触发器就是DOCTYPE，没有DCTYPE意味着触发怪异模式，任何新的或者未知的DUCTYPE会触发严格模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS盒子模型&lt;br&gt;一个盒子模型是由长宽，边框，内填充，外边距构成的如下图&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c3fd4c29ly1fm11r9p5dij205j05bglh.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;可以知道总元素的
      
    
    </summary>
    
    
      <category term="Css" scheme="http://longfeihouhouhou.github.io/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>flex布局和弹性盒子</title>
    <link href="http://longfeihouhouhou.github.io/flex%E5%B8%83%E5%B1%80%E5%92%8C%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90.md/"/>
    <id>http://longfeihouhouhou.github.io/flex布局和弹性盒子.md/</id>
    <published>2018-03-09T15:32:51.000Z</published>
    <updated>2018-03-09T15:33:24.456Z</updated>
    
    <content type="html"><![CDATA[<p>##CSS3弹性盒子flex布局</p><blockquote><p>弹性盒子是css3一种新的布局模式，他能更有效的对元素进行排列，对齐，分配空间。弹性盒子外和子元素内是正常渲染的，弹性盒子只定义了<code>弹性子元素</code>如何<code>在弹性容器</code>内渲染。弹性子元素默认每个容器只有一行，弹性子元素在弹性盒子内一行显示</p></blockquote><ol><li><p>direction：</p><blockquote><p>设置<code>direction</code>属性为<code>rtl</code>(right-to-left)弹性子元素排列改变，页面布局也会跟变化</p></blockquote></li><li><p>flex-direction方法</p><blockquote><p>flex-direction 指定了弹性子元素在父容器的位置，排列方式横向和纵向，正向和反向</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-directi<span class="symbol">on:</span> <span class="built_in">row</span> | <span class="built_in">row</span>-reverse | <span class="built_in">column</span> | <span class="built_in">column</span>-reverse</span><br></pre></td></tr></table></figure></blockquote></li><li><p>justify-content属性</p><blockquote><p>制定了 弹性子元素在行内如何对齐</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content:flex-start | flex-<span class="keyword">end</span> | center | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-<span class="keyword">around</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><p>4 .align-items属性</p><blockquote><p>align-items 设置或检索弹性盒子元素在纵轴上的对齐方式<br>值同<code>justify-content</code>类似<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span></span><br></pre></td></tr></table></figure></p></blockquote><ol><li>flex-wrap属性<blockquote><p>flex-wrap属性用于指定弹性盒子的子元素换行方式</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap: nowrap | <span class="type">wrap</span> | <span class="type">wrap</span>-reverse | <span class="type">initial</span> |<span class="type">inherit</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><p>各各值解析: </p><ul><li>nowrap :默认单行，子元素可能会溢出</li><li>wrap ： 多行，溢出部分放入新行，子项内部会发生断行</li></ul><ol><li>align-content属性<blockquote><p>用于修改flex-wrap属性，类似<code>align-items</code>但是它不是修改对齐，而是设置各个行的对齐</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##CSS3弹性盒子flex布局&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;弹性盒子是css3一种新的布局模式，他能更有效的对元素进行排列，对齐，分配空间。弹性盒子外和子元素内是正常渲染的，弹性盒子只定义了&lt;code&gt;弹性子元素&lt;/code&gt;如何&lt;code&gt;在弹性容器&lt;/co
      
    
    </summary>
    
    
      <category term="CSS" scheme="http://longfeihouhouhou.github.io/tags/CSS/"/>
    
      <category term="flex" scheme="http://longfeihouhouhou.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>Css特性</title>
    <link href="http://longfeihouhouhou.github.io/Css%E7%89%B9%E6%80%A7.md/"/>
    <id>http://longfeihouhouhou.github.io/Css特性.md/</id>
    <published>2018-03-09T15:31:43.000Z</published>
    <updated>2018-03-09T15:32:13.718Z</updated>
    
    <content type="html"><![CDATA[<p>元素左右居中</p><ul><li><ol><li>内联元素: text-align:centerte</li></ol></li><li><ol><li>定宽块级元素：margin: 0 auto</li></ol></li><li><ol><li>不定宽块级元素：<ul><li>a.  元素外面加入完整的table标签（table,tbody,tr,td）在td内设置margin的值为auto</li><li>b. 使用display:inline-block 再 text-align</li><li>c. 增加一个父级盒子 给父级盒子设置向左浮动，相对定位，left：50%  ，给子盒子相对定位，left值为-50%</li><li>d. 利用transform中的translateX属性，设置绝对定位，left：50%在translateX（-50%）<br>##元素垂直居中</li></ul></li></ol></li><li><ol><li>父元素高度确定的单行文本：设置父元素的height和line-height</li></ol></li><li><ol><li>父元素高度确定的多行文本：<br>   a:  插入table，设置vertical-align：middle<br>   b: 先设置display：table-cell 在设置verticala-align：middle</li></ol></li><li><ol><li>flex布局解决方法：<br>display:flex<br>align-items:center;<br>##解决img标签间隙问题</li></ol></li><li><ol><li>给父元素设置font-size: 0</li></ol></li><li><ol><li>设置display：block</li></ol></li><li><ol><li>设置图片margin为负值<br>##浮动<blockquote><p> 定义：浮动元素会脱离文档流向左/右浮动，直到碰到父元素或者其他浮动元素，值得注意的是当同时有多个浮动元素，大小不一致的情况下可能会导致“卡住”</p></blockquote>###浮动元素会导致父级元素高度坍塌<blockquote><p>浮动元素脱离文档流，如果父级盒子没设置高度，而是靠子级撑开的话，会导致没了高度</p></blockquote>###清除浮动<blockquote><p>清除浮动主要方法是clear和BFC</p></blockquote></li></ol></li><li>clear属性不允许被清除浮动元素的左边/右边挨着浮动元素，底层原理是在被清除浮动元素上边或者下边添加足够的清除空间。<br>给浮动元素父元素加一个after伪类，表示加载完后在内容里面追加。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:table;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果需要兼容IE6/7的话需要给父元素一个<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">.clearfix&#123;</span></span><br><span class="line"><span class="code">*zoom:1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>BFC以后再总结，目前clear就够了</p></blockquote><p>###图片在div中，div下面会有4像素的空白</p><blockquote><p>方法： 给图片display block 或者 table  还有就是margin…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;元素左右居中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;内联元素: text-align:centerte&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;定宽块级元素：margin: 0 auto&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Css" scheme="http://longfeihouhouhou.github.io/tags/Css/"/>
    
      <category term="布局" scheme="http://longfeihouhouhou.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>简单总结js的设计模式</title>
    <link href="http://longfeihouhouhou.github.io/%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93js%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md/"/>
    <id>http://longfeihouhouhou.github.io/简单总结js的设计模式.md/</id>
    <published>2018-03-09T15:28:55.000Z</published>
    <updated>2018-03-09T15:30:20.438Z</updated>
    
    <content type="html"><![CDATA[<p>##简单总结JS设计模式</p><p>[toc]</p><p>###工厂模式</p><blockquote><p>目的：解决多个类似对象声明的问题，也就是解决实例化对象产生重复的问题，把实现同一件事情的相同代码放在一个函数中，以后想要使用，不用重新编写，只要函数执行。也叫“函数的封装”<br>优点：能解决多个相似的问题，减少代码量，提高代码利用率<br>缺点：</p></blockquote><p>###单例模式</p><blockquote><p>用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。<br>优点：</p><ol><li>可以用来划分命名空间，减少全局变量的数量；</li><li>使用单例模式可以使代码清晰，容易阅读和维护。</li><li>可以被实例化，切可以被实例化一次</li></ol></blockquote><p>###原型模式</p><blockquote></blockquote><p>###观察者模式</p><blockquote></blockquote><p>###</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##简单总结JS设计模式&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;###工厂模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目的：解决多个类似对象声明的问题，也就是解决实例化对象产生重复的问题，把实现同一件事情的相同代码放在一个函数中，以后想要使用，不用重新编写，只要函数执行
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>解决JS阻塞特性</title>
    <link href="http://longfeihouhouhou.github.io/%E8%A7%A3%E5%86%B3JS%E9%98%BB%E5%A1%9E%E7%89%B9%E6%80%A7.md/"/>
    <id>http://longfeihouhouhou.github.io/解决JS阻塞特性.md/</id>
    <published>2018-03-09T15:27:40.000Z</published>
    <updated>2018-03-09T15:28:00.759Z</updated>
    
    <content type="html"><![CDATA[<p>##<code>JS</code>特性之阻塞</p><p>@(JavaScript)</p><blockquote><p>代码是从上到下逐行执行，<code>JS</code>有阻塞性，当浏览器解析<code>JS</code> 时候是不能干别的事情的（<code>css</code>是并行下载不会阻塞页面的其他进程），因此每当遇到script标签，页面都会等待脚本下载并执行，这会停止页面绘制，所有必要减少JS阻塞造成的困扰。</p></blockquote><p>###解决方法</p><ul><li>优化脚本位置<br>script可以方法body或者head中，浏览器在执行到body之前不会渲染页面，把js放在head中会导致延迟，虽然新一代浏览器都支持并行下载JS，但是JS下载扔会阻塞其他资源的下载（图片），因此script尽量放到body底部</li><li>减少外链脚本数量以改善性能<br>  额外的HTTP请求会带来额外的开销</li><li>使用无阻塞下载JS方法<br> 在页面加载完成之后再加载JS，即Window对象的load事件触发后再下载脚本</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;code&gt;JS&lt;/code&gt;特性之阻塞&lt;/p&gt;
&lt;p&gt;@(JavaScript)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码是从上到下逐行执行，&lt;code&gt;JS&lt;/code&gt;有阻塞性，当浏览器解析&lt;code&gt;JS&lt;/code&gt; 时候是不能干别的事情的（&lt;code&gt;c
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS中this的指向问题</title>
    <link href="http://longfeihouhouhou.github.io/JS%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98.md/"/>
    <id>http://longfeihouhouhou.github.io/JS中this的指向问题.md/</id>
    <published>2018-03-09T15:22:59.000Z</published>
    <updated>2018-03-09T15:23:27.373Z</updated>
    
    <content type="html"><![CDATA[<p>##JS中的this指向</p><blockquote><p>1.函数中的this，指向的是调用这个函数的对象，具体说是指向这个函数的上一级对象，如果函数定义在window，那么它的上一级对象自然是window，如果函数上一级没有调用的this，那么this是window<br>2.构造函数中的this指向他的实例，值得注意的是如果return一个引用数据类型，会覆盖实例</p></blockquote><p>###四种函数形态</p><ol><li><p>函数形态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法调用形态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.foo = foo ;</span><br><span class="line">o.foo() ; <span class="comment">//object</span></span><br></pre></td></tr></table></figure></li></ol><hr><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">lib</span> = &#123;</span><br><span class="line"><span class="function"><span class="keyword">fn</span>:function<span class="params">()</span>&#123;</span></span><br><span class="line"><span class="function">console.<span class="built_in">log</span><span class="params">(this)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">&#125; </span></span><br><span class="line"><span class="function"><span class="keyword">lib</span>.<span class="keyword">fn</span><span class="params">()</span></span>;    <span class="comment">//lib 对象本身</span></span><br></pre></td></tr></table></figure><ol><li>构造函数调用模式</li><li></li><li>aplly调用模式，这些模式在如何初始化关键参数this上存在差异。<br>###闭包<blockquote><p>通过函数字面量创建的函数对象包含一个连到外部上下文的连接</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##JS中的this指向&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.函数中的this，指向的是调用这个函数的对象，具体说是指向这个函数的上一级对象，如果函数定义在window，那么它的上一级对象自然是window，如果函数上一级没有调用的this，那么this是windo
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Js中的事件</title>
    <link href="http://longfeihouhouhou.github.io/Js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6.md/"/>
    <id>http://longfeihouhouhou.github.io/Js中的事件.md/</id>
    <published>2018-03-09T15:15:37.000Z</published>
    <updated>2018-03-09T15:27:05.341Z</updated>
    
    <content type="html"><![CDATA[<p>#JS中的事件</p><p>##事件冒泡</p><blockquote><p>事件的触发顺序自内向外，这就是事件冒泡。例如点击事件，点击子元素，由于事件冒泡会触发父元素的点击事件，一直到body<br>在监听函数中第三个参数是布尔值，true为捕获，false为冒泡，默认是false，由下向上触发事件<br>IE浏览器只支持事件冒泡，它也不支持addEventListener函数，而是提供另一个函数attachEvent<br> <img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fm28nx50jcj20ja0eft9e.jpg" alt=""><br>解决冒泡的方法：</p></blockquote><ol><li><p>阻止冒泡传播，加入event.stopPropagation，终止事件的广播分发，这样事件就会停留在本节点，不会在向上传播</p></li><li><p>判断事件触发的节点和当前处理事件节点的引用是否相等</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span>.target==<span class="keyword">event</span>.currentTarget</span><br></pre></td></tr></table></figure><p> 弊端是需要每一个节点都要处理，代码量冗余，解决办法是使用事件委托</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'body'</span>).addEventListener(<span class="string">'click'</span>,fn);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> target=e.target</span><br><span class="line">swich (target.id)&#123;</span><br><span class="line"><span class="keyword">case</span>: <span class="string">'parent'</span>:</span><br><span class="line">alert (<span class="string">'您好，我是'</span>+target.id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>: <span class="string">'child'</span>:</span><br><span class="line">alert (<span class="string">'您好，我是'</span>+target.id);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#JS中的事件&lt;/p&gt;
&lt;p&gt;##事件冒泡&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事件的触发顺序自内向外，这就是事件冒泡。例如点击事件，点击子元素，由于事件冒泡会触发父元素的点击事件，一直到body&lt;br&gt;在监听函数中第三个参数是布尔值，true为捕获，false为冒泡，
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="javascript" scheme="http://longfeihouhouhou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器都有那些分类？</title>
    <link href="http://longfeihouhouhou.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F.md/"/>
    <id>http://longfeihouhouhou.github.io/浏览器都有那些分类？.md/</id>
    <published>2018-03-09T15:13:21.000Z</published>
    <updated>2018-03-09T15:13:55.876Z</updated>
    
    <content type="html"><![CDATA[<p>##浏览器的分类</p><p>@(计算机基础)</p><p>根据内核属性将浏览器分为四类：</p><ul><li>1 . <strong>IE6/7/8/9/10/11  Trident  (IE内核)</strong><br>常见的浏览器：<br>2345浏览器、腾讯TT、淘宝浏览器、阿云浏览器（早期版本）、瑞星安全浏览器、蚂蚁浏览器、飞腾浏览器、速达浏览器、佐罗浏览器、海豚浏览器等等</li><li>2 .  <strong>firefox    (Gecko/Firefox)</strong><br>特点：代码完全公开，任何人都可以为其编写代码。不过以gecko为内核的浏览器Firefox最多，所以也称firefox内核<br>常见的浏览器：<br>Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）等等 </li><li>3 . <strong>WebKit   (webkit内核是chrome和safair的内核原型)</strong><br>  webkit是苹果公司研发，两大主力浏览器chrome和safair都是基于webkit，严格来说chrome的内核是基于webkit的分支而发展成的chromuim<br>  常见浏览器：<br>  Chrome(v8引擎)360 浏览器、搜狗浏览器 、傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器</li><li>4 . <strong>opera (presto内核)</strong><br>  公认网页浏览速度最快的浏览器内核，代价是牺牲了网页的兼容性，执行同等的js所需时间仅为trident和gecko的 1/3 ，由于是商业引擎，使用的浏览器较少<br>  常见浏览器：下NDSBrowser、Wii Internet Channle、Nokia 770网络浏览器等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##浏览器的分类&lt;/p&gt;
&lt;p&gt;@(计算机基础)&lt;/p&gt;
&lt;p&gt;根据内核属性将浏览器分为四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 . &lt;strong&gt;IE6/7/8/9/10/11  Trident  (IE内核)&lt;/strong&gt;&lt;br&gt;常见的浏览器：&lt;br&gt;2345浏览器、
      
    
    </summary>
    
    
      <category term="浏览器" scheme="http://longfeihouhouhou.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>图解HTTP</title>
    <link href="http://longfeihouhouhou.github.io/%E5%9B%BE%E8%A7%A3HTTP.md/"/>
    <id>http://longfeihouhouhou.github.io/图解HTTP.md/</id>
    <published>2018-03-09T15:12:14.000Z</published>
    <updated>2018-03-09T15:12:58.436Z</updated>
    
    <content type="html"><![CDATA[<p>#图解HTTP</p><p>###HTTP 超文本传输协议<br>HTTP： HyperText Transfer Protocol </p><hr><p>一个请求从客户端到服务端的流程<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1flxr2yyvi2j20h90fkjww.jpg" alt=""><br>客户端从应用层（HTTP协议）发送一个HTTP请求。<br>接着，为了传输方便，会在传输层（TCP协议）把从应用层收到的HTTP请求报文进行分割，并在各个报文打上端口号和序号转发给网络层。<br>在网络层（IP协议），增加作为通信目的地MAC地址后转发给链路层。这样给发往网络的通信请求就齐全了。</p><blockquote><p>发送端在层与层的传递时，每经过一层都会打上该层所属的首部信息，相反，服务端在接受信息时每经过一层都会去掉该层所属的首部信息。<br>TCP/IP 协议族中IP占了一半，IP就是网络协议，IP协议的作用就是将数据包传送给对方，而为了确保准确传送，IP地址和MAC地址就是重要条件</p></blockquote><hr><p>###TCP的三次握手<br>TCP位于传输层，提供可靠的字节流服务，字节流是指为了方便传输，将大块数据分割以报文段为单位的数据包进行管理，可靠的传输服务是指TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否到达对方<br>，为了确保数据送达，TCP协议采用三次握手策略：<br>发送端首先发送一个带SYN标志的数据包给对方，接收端收到后回复带SYN/ACK标志的数据包以示消息传达确认消息，最后发送端再传回一个带ACK标志的数据包代表握手结束</p><p>###DNS（Domian Name System）<br>域名服务系统和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问，因为与IP地址的一组纯数字相比，用字母配合数字更符合人类的记忆习惯。<br>DNS协议提供通过域名查找IP地址，或逆向从IP地址反查找域名的服务。</p><hr><p>###各种协议与HTTP协议的关系<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly05ta14mj20cl0i2dld.jpg" alt=""></p><p>###URI与URL<br>即 统一资源标识符和统一资源定位符，URI用字符串表示某一互联网资源，而URL表示资源在互联网所处的位置。</p><p>##HTTP协议</p><ul><li>用于客户端和服务端的通信</li><li>通过请求和响应的交换达成通信<blockquote><p>请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的</p></blockquote></li></ul><p>请求报文的构成<br> <img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly0z5ra0hj20cs06gabc.jpg" alt=""></p><hr><p> 响应报文的构成<br> <img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly129hjsjj20b305njsd.jpg" alt=""><br> HTTP协议本身不具备保存之前发送过的请求或响应的功能，使用HTTP协议本身并不保留之前一切的请求或响应报文的信息。HTTP虽然是无状态协议，但是为了实现期望的保存状态功能，于是引入了Cookie技术，有了Cookie再用HTTP协议通信，就可以管理状态了。<br> 使用URI来定位访问的资源</p><p>###HTTP方法<br>使用HTTP方法来告诉服务器意图<br>GET：获取资源<br>POST：传输实体主体<br>GET和POST使用很相似，但POST的主要目的并不是获取相应的主体内容<br>PUT：用来传输文件，因为HTTP/1.1的PUT方法自身不带验证机制，一般web网站不使用它<br>HEAD：和GET一样，但是不返回报文主体，值返回响应首部<br>DELETE ： 删除文件，同PUT相反，机制类似所以一般网站不会开放DELETE方法。<br>….<br><img src="http://ww1.sinaimg.cn/large/c3fd4c29ly1fly48gcrr0j20dz08zgmx.jpg" alt=""></p><hr><p>###TCP的持久链接<br>当一个网站需要大量请求时，会建立多次TCP，每次请求都会造成TCP的链接和断开，造成通信量的开销HTTP1.1提出HTTP keep-alive的方法，只要任意一端没有提出明显的断开，就是一直持久链接，在HTTP1.1中多有的链接都是持久链接</p><p>###Cookie的状态管理<br>HTTP是无状态协议，它不对之前发生过的请求和响应进行状态管理，无状态的优点是：由于不必保存状态，自然可以减少服务器的CPU以及内存的消耗，从侧面说正是HTTP协议本身简单才会被应用各种场景。<br>Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。<br>cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在报文中加入cookie值后发送出去。<br>服务器端发现客户端发送过来的cookie后，会去检查究竟是从哪一个客户端发来的链接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#图解HTTP&lt;/p&gt;
&lt;p&gt;###HTTP 超文本传输协议&lt;br&gt;HTTP： HyperText Transfer Protocol &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一个请求从客户端到服务端的流程&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://longfeihouhouhou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>react入门</title>
    <link href="http://longfeihouhouhou.github.io/react%E5%85%A5%E9%97%A8.md/"/>
    <id>http://longfeihouhouhou.github.io/react入门.md/</id>
    <published>2018-03-09T15:11:06.000Z</published>
    <updated>2018-03-09T15:11:43.730Z</updated>
    
    <content type="html"><![CDATA[<p>#初识react</p><p>[toc]</p><p>##react安装<br><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm </span><span class="string">install </span><span class="built_in">create-reacte-app</span> -g</span><br><span class="line"><span class="built_in">create-reacte-app</span> <span class="string">my </span><span class="string">app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app</span></span><br><span class="line"><span class="string">npm </span><span class="string">start</span></span><br></pre></td></tr></table></figure></p><hr><p>##JSX简介<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure></p><p>这种标签语法不是html也不是字符串，而是JSX，一种javascipt语法扩展，在React中推荐使用jsx来描述用户界面<br><strong>使用</strong></p><ul><li>可以任意的在jsx中使用js表达式, 但是要包含在大括号中。</li><li>在书写jsx时候 一般带上换行和缩进，增强代码可读性, 推荐在jsx代码外扩上一个小括号，放置分号自动插入的bug</li><li>jsx本身也是一种表达式，也就是说可以在if 或者for语句使用jsx，将他赋值给变量，当作参数传入，作为返回值。</li><li>属性:<br>  使用引号来定义以字符串为值的属性，使用大括号来定义以js表达式为值的属性<br><strong>JSX代表Object</strong><br>Babel转译器会把jsx转换成一个名为React.createElement()的方法调用。这个方法会返回一个对象，这样的对象被称为 React元素，react通过读取这些对象来构建DOM并保持数据一致<br>##元素渲染<br>元素是构成React应用的最小单位<br>React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">渲染方法</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>##React组件<br><strong>组件定义的方式</strong><br>第一种：js普通函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种： es6类<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件，这个对象称之为”props”</p><blockquote><p> 警告:<br> 组件名称必须大写字母开头 </p></blockquote><p>React非常灵活，但是有一个严格的规则：<br><strong>所有的React组件必须像纯函数那样使用他们的props</strong></p><blockquote><p>纯函数： 函数执行不会改变自己的输入值，当传入值相同时总能返回相同的结果</p></blockquote><p>##state状态<br><strong>将函数转换为类</strong></p><ol><li>创建一个名称扩展为React.Component的ES6类</li><li>创建一个叫做render( )的空方法</li><li>将函数体移动到render( )方法中</li><li>在render( )方法中，使用this.props替换props</li><li>删除剩余空函数声明</li></ol><p>使用类才能允许我们使用其他特性，例如局部状态，生命周期钩子<br><strong>给一个类添加局部状态</strong></p><ol><li>在render方法中使用this.state.date替代this.props.date</li><li>添加一个类构造函数来初始化this.state</li><li>从 <code>&lt;Clock/&gt;</code>元素移除date属性</li></ol><p>结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>接下来，使用Clock设置计时器，每秒刷新一次，这样就会用到生命周期</p><p>##生命周期<br>每当Clock组件第一次加载到DOM中的时候，我们都想生成定时器，这在React中被称为挂载。</p><p>同样，每当Clock生成的这个DOM被移除的时候，我们也会想要清除定时器，这在React中被称为卸载。</p><p>我们可以在组件类上声明特殊的方法，当组件挂载或卸载时，来运行一些代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span><span class="params">()</span></span>&#123;<span class="comment">//建立定时器</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span><span class="params">()</span></span> &#123;<span class="comment">//卸载定时器</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这些方法被称作生命周期钩子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>让我们回顾下发生了什么，一级调用方法的顺序</p><ol><li>当<code>&lt;clock/&gt;</code>被传递给ReactDOM.render( )时, React调用Clock组件的构造函数。由于Clock需要显示当前时间，所以使用包含当前时间的对象来初始化this.state。我们稍后会更新此状态</li><li>然后 React 调用Clock组件的render( )方法. 这是React 了解屏幕上应该显示什么内容的原因，然后React更新Dom 以匹配Clock的渲染输出。</li><li>让clock的输出插入到DOM中时，React调用componentDidMount( )生命周期钩子.在其中，clock组件要求浏览器设置一个定时器，每秒执行一次</li><li>浏览器每秒调用tick( )方法，在其中Clock 组件通过使用包含当前的对象，调用setState( )来调度UI更新。 通过调用setState( )，React知道状态已经改变 ，并再次调用render( )方法来确定屏幕上应当显示什么，这一次render( )方法中的this,state.date将不同, 所以渲染输出将包含更新的事件，并响应的更新DOM.</li><li>一旦Clock组件被从Dom中移除，React会调用componentWillUnmount( )这个钩子函数，定时器也就会被清除</li></ol><p>##正确的使用状态<br>关于<code>setState()</code>的三件事情：<br><strong>1 不要直接更新状态</strong><br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.<span class="keyword">state</span>.comment = 'Hello';</span><br></pre></td></tr></table></figure></p><p>应该使用setState( )<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="string">comment:</span> <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>构造函数是位移能够初始化<code>this.state</code>的地方。<br><strong>状态更新可能是异步的</strong><br>React可以将多个setState( )调用 合并成一个调用来提高性能。<br>因为this.props和this.state可能是异步更新的，不应该靠他们的值来计算下一个状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#初识react&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;##react安装&lt;br&gt;&lt;figure class=&quot;highlight dsconfig&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="react" scheme="http://longfeihouhouhou.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>react-redux的状态管理</title>
    <link href="http://longfeihouhouhou.github.io/react-redux%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.md/"/>
    <id>http://longfeihouhouhou.github.io/react-redux的状态管理.md/</id>
    <published>2018-03-09T15:08:23.000Z</published>
    <updated>2018-03-09T15:10:20.676Z</updated>
    
    <content type="html"><![CDATA[<p>##Redux</p><p>[toc]</p><p>###1.Redux应用场景<br>因为单页面应用内容越来越复杂，所以管理不断变化的state非常困难，在React中，数据在组件中是单向流动的，兄弟组件之间的通信就会比较麻烦<img src="./redux-wrong.png" alt="Alt text"></p><p>###2. Redux设计思想</p><ul><li>Redux是将整个应用状态存储到一个地方，称为store,里面保存一颗状态树(<code>state  tree</code>)。（因为状态一般都用对象，而对象都是树形结构）组件可以派发(dispatch) 行为 action 给store，而不是直接通知其他组件。组件内部通过订阅store中的状态state 来刷新自己的视图。<br><img src="./redux-flow.png" alt="Alt text"><br>###3. Redux三大原则</li></ul><ol><li>整个应用的state被储存在一颗object tree中，并且存在一个唯一一个store中</li><li>state是只读的，唯一改变state的方法就是触发action ，action是一个用于描述已发生事件的普通对象</li><li>使用纯函数来执行修改，为了描述action 如果改变state tree 你需要编写reducers</li></ol><ul><li>单一数据源的设计让React的组件之间的通信更加方便，同时便于状态的统一管理<br>###4.Redux解析概念</li></ul><hr><ul><li><p>4.1 Store</p><ul><li>store 就是保存数据的地方，可以把它看成一个容器，整个应用只能有一个store</li><li><p>Redux 提供createStore 方法，用来生成store </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(fn)</span><br></pre></td></tr></table></figure><p>  上面代码中createStore函数接受另一个函数作为参数，返回新生成的store对象。</p></li></ul></li><li><p>4.2 State<br>  Store对象包含所有数据，如果想要得到某个时点的数据，就要对Store生成快照。这种时间点的数据集合，就叫做State。当前时刻的State，可以通过store.getState( )拿到。</p>  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore&#125; <span class="keyword">from</span> 'redux'</span><br><span class="line">const store=createStore(fn)</span><br><span class="line">const <span class="keyword">state</span>=store.getState()</span><br></pre></td></tr></table></figure><ul><li><p>4.3 Action<br>  state的变化会导致view的变化，但是用户接触不到State，只能解触到view，所以state的变化必须是view导致的。action就是view发出的通知，表示state应该快要发生变化了，action是一个对象。其中的type属性是必须的，表示action的名称。其他属性可以自由设置，社区有一个规范可以参考</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action=&#123;</span><br><span class="line"><span class="keyword">type</span>:<span class="string">'ADD_TODO'</span>,</span><br><span class="line">playload:<span class="string">'学习Redux'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面代码中，action的名称是ADD_TODO，它携带的信息是字符串’学习Redux’ 这样可以理解，action描述当前发生的事情，可以改变State的唯一办法，就是使用ation ，它可以运送数据到Store</p></li></ul></li><li>4.4 Action Creator<br>view要发送多少种信息，就会有多少种action，如果都手写太麻烦，可以定义一个函数来生成action，这个函数就叫action creator<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加TODO'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span><span class="params">(text)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">type:ADD_TODO,</span><br><span class="line">text</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> action=addTodo(<span class="string">'学习Redux'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>上面代码中，addTodo函数就是一个Action Creator</p><ul><li><p>4.5 store.dispatch()<br>  store.dispatch() 是view发出action的唯一方法。</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> store=createStore(fn)</span><br><span class="line">store.dispatch(&#123;</span><br><span class="line"><span class="keyword">type</span>:<span class="string">'ADD_TODO'</span>,</span><br><span class="line">payload:<span class="string">'学习Redux'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>  上面代码中store.dispath 接受一个action对象作为参数，将它发送出去，结合Action Creator，这段代码可以改写如下。</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">store</span><span class="selector-class">.dispatch</span>(addTodo(<span class="string">'学习Redux'</span>))</span><br></pre></td></tr></table></figure></li><li><p>4.6 Reducer<br>Store收到Action以后，必须给一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个纯函数，它接受Action和当前state作为参数，返回一个新的State。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer =<span class="function"><span class="keyword">function</span><span class="params">(state,action)</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> new_state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何使用redux"><a href="#如何使用redux" class="headerlink" title="如何使用redux"></a>如何使用redux</h2><ol><li>后台写一个后台接口  /lessons</li><li>前台(api)里写一个获取接口数据的方法</li><li>在action-types里添加新的actionType类型</li><li>在reducer里修改初始状态，并添加一个case</li><li>在<code>actions</code>里添加一个方法调用此方法</li><li>在组件中调用action中的方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##Redux&lt;/p&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;###1.Redux应用场景&lt;br&gt;因为单页面应用内容越来越复杂，所以管理不断变化的state非常困难，在React中，数据在组件中是单向流动的，兄弟组件之间的通信就会比较麻烦&lt;img src=&quot;./redux-wro
      
    
    </summary>
    
    
      <category term="react" scheme="http://longfeihouhouhou.github.io/tags/react/"/>
    
      <category term="react-redux" scheme="http://longfeihouhouhou.github.io/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件化开发</title>
    <link href="http://longfeihouhouhou.github.io/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.md/"/>
    <id>http://longfeihouhouhou.github.io/Vue组件化开发.md/</id>
    <published>2018-03-09T14:56:12.000Z</published>
    <updated>2018-03-09T15:05:56.894Z</updated>
    
    <content type="html"><![CDATA[<p>##Vue组件化开发</p><ul><li>单页应用（一个页面）<br>##组件</li><li>把一个复杂的页面拆分成若干个组件，最后拼成一个完整的页面。组件就是自定义标签，封装可重用代码<h2 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h2></li><li>页面级组件（home组件 list组件）</li><li>基础组件（页面级包含基础级，也可以叫可复用组件）<h2 id="组件化开发的好处"><a href="#组件化开发的好处" class="headerlink" title="组件化开发的好处"></a>组件化开发的好处</h2></li><li>提高开发效率</li><li>方便重复使用</li><li>便于协同开发</li><li>更容易被管理和维护<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2></li><li>全局组件（不需要在组件中再次声明）<ul><li>写插件时可能会需要用到全局组件</li></ul></li><li>局部组件（在某个组件中声明的）<ul><li>自己写的组件一般是局部组件<br>##组件的特点<br>1、组件的名字不能使用已经存在的东西<br>2、一个组件就是一个对象<br>3、名字规范，js中不区分标签大小写<br>4、组件模版中只能有一个根节点，所有组件都是基于根实          例的<br>5、 组件中的data 必须是一个函数，<br>6、组件中的data 只能自己组件使用<br>7、组件相互独立，两个人之间没有任何关系<h2 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">component</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> my=&#123;</span><br><span class="line">template:<span class="string">'&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span>,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;msg:<span class="string">'hello'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.component(<span class="string">'my-component'</span>,my)</span><br></pre></td></tr></table></figure><p>##局部组件<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">vm</span>=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="keyword">e</span><span class="variable">l:</span><span class="string">'#app'</span>,</span><br><span class="line">component<span class="variable">s:</span>&#123;</span><br><span class="line">child:&#123;</span><br><span class="line">template:<span class="string">'&lt;div&gt;子组件&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>定义在内部，而不是挂载在全局<h2 id="组件间的数据传递prop"><a href="#组件间的数据传递prop" class="headerlink" title="组件间的数据传递prop"></a>组件间的数据传递prop</h2></li><li>组件实例的作用域是孤立的，互相不能访问</li><li>给谁传递属性，就写在谁身上，通过冒号传递，可以传递数字，变量，布尔类型</li><li>子组件需要显示声明在props 上</li><li>属性的名字要使用驼峰命名法，因为要加载到html上</li><li>使用四种验证方式，验证数据的传入方式</li><li>这意味着不能（也不应该）在子组件模版内直接引用父组件的数据。父组件的数据<br>##单向数据流<h3 id="事件Event是子传父"><a href="#事件Event是子传父" class="headerlink" title="事件Event是子传父"></a>事件Event是子传父</h3></li><li>在子组件上绑定自定义函数，对应的事件函数是父类的</li><li>子组件触发自己的自定义事件，让父类执行</li></ul><p>2、父组件发生变化，刷新子组件</p><hr><p>##重点</p><ul><li>全局组件和局部组件的使用</li><li>局部组件的模版</li><li>组件中的数据必须是函数诶型</li><li>属性的嵌套</li><li>属性的传递</li><li>属性的验证</li><li>父组件获取子组件数据和方法</li></ul><p>##路由</p><ul><li>不同的url返回不同的结果</li><li>vue的路由（spa）中只有一个首页，切换url地址，显示不同的组件</li><li>切换路径，但是页面不切换<ul><li>hash #</li><li>pushState  没井号 (在开发的时候会产生404)，如果线上时会使用这种方式，可以依赖服务端解决404问题</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##Vue组件化开发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单页应用（一个页面）&lt;br&gt;##组件&lt;/li&gt;
&lt;li&gt;把一个复杂的页面拆分成若干个组件，最后拼成一个完整的页面。组件就是自定义标签，封装可重用代码&lt;h2 id=&quot;组件的分类&quot;&gt;&lt;a href=&quot;#组件的分类&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="vue" scheme="http://longfeihouhouhou.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>初识express</title>
    <link href="http://longfeihouhouhou.github.io/%E5%88%9D%E8%AF%86express.md/"/>
    <id>http://longfeihouhouhou.github.io/初识express.md/</id>
    <published>2018-03-09T14:54:54.000Z</published>
    <updated>2018-03-09T15:27:05.361Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><ul><li><p>express是一个简洁快速node.js开发框架<br>##使用express</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> express</span><br></pre></td></tr></table></figure></li><li><p>获取、引用 通过变量app我们就可以调用express的各种方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">express</span> = require('<span class="built_in">express</span>');</span><br><span class="line"><span class="built_in">var</span> app = <span class="built_in">express</span>();</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p>###练习</p><ul><li>当客户端以get方式访问</li><li>如果有一天，你忘记了请求和响应的格式。 打开gitbash<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入　</span><br><span class="line">curl <span class="params">--verbose</span> http:<span class="string">//localhost</span><span class="function">:8080</span>/user</span><br><span class="line">curl <span class="params">--verbose</span> <span class="params">--data</span> <span class="string">"name=zfpx"</span> -X POST http:<span class="string">//localhost</span><span class="function">:8080</span>/user</span><br></pre></td></tr></table></figure></li></ul><p>##send 方法</p><ul><li>send 方法可以接受任何类型的参数：字符串 buffer 对象  数组 数字 ，主要是数据类型转换 ，把其他类型都转成end能处理的类型，也就是字符串或者buffer</li><li>发送文件的sendFile 但是需要绝对路径，或者指定root根目录</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;express是一个简洁快速node.js开发框架&lt;br&gt;##使用express&lt;/p&gt;
&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://longfeihouhouhou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nodeJs" scheme="http://longfeihouhouhou.github.io/tags/nodeJs/"/>
    
  </entry>
  
  <entry>
    <title>GIT进阶操作</title>
    <link href="http://longfeihouhouhou.github.io/GIT%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C.md/"/>
    <id>http://longfeihouhouhou.github.io/GIT进阶操作.md/</id>
    <published>2018-03-09T14:34:49.000Z</published>
    <updated>2018-03-09T14:51:30.366Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在做团队项目时会使用GIT来进行团队分工和配合，那么正确使用GIT的流程是什么样子的呢，分支又是如何利用的呢？</p><ul><li>最开始我们在<code>git hub</code>上创建一个仓库，然后在项目的setting选项中选择<code>Collaborators</code>，通过用户名来邀请合作者，邀请发出后，被邀请额合作者会在绑定邮箱中收到邀请函。接受邀请后就可以一同开发这个在GIT上的项目了</li><li>我们会首先使用<code>git clone https://github.com/xxxxx/xxxxxx.git</code>指令在<code>git bash</code>命令行中来将仓库下载下来，当你推送修改的时候要使用<code>git push origin master</code>指令推送。不过在<code>git push</code>之前 必须要执行 <code>git add .</code>和<code>git commit -m&#39;本次提交名字&#39;</code>  两个步骤操作，这个是必须的，要弄白为什么，就得理解<code>git hub</code>的三个分区。</li><li><code>git hub</code>有三个分区，分别是 <code>工作区</code> <code>暂存区</code> <code>历史区</code> <ul><li>工作区指的是当前当前代码编辑进行区域，暂存区是执行<code>git add</code>指令后文件暂存的区域，而历史区则是你的版本历史区域，也就是说你可以有多个历史区文件，但是暂存区只有一个（只有一个分支情况下），那么暂存区和历史区有什么必要性呢？</li><li>先说历史区，他能收集你多个时间段的代码，多个时间段的版本也就是<code>git commit</code>，多次提交的版本，例如 1.0版 1.1版 2.1版，当你代码出错找不到解决办法的时候，可以使用版本回退，来回到你想回到的版本，而<code>git commit -m</code>后面的字段就是版本的名称，所以写好版本名是非常有必要的</li><li>再说暂存区，说到暂存区就不得不提及<code>git</code>  分支的好处了，当同时有多人开发同一个项目时，难免会出现冲突，所谓冲突就是多个人对同一个文件进行了不同的修改，例如<code>README</code>文件的第一行，如果张三和李四都对这个文件的第一行进行了修改，并且是有差异的修改，那么<code>git hub</code> 会对这两个两个修改表示出无法处理，它不知道第一行到底是接受张三的还是李四的。</li></ul></li><li><p>所以一般我们在提交代码之前先要使用<code>git pull origin master</code>将<code>git hub</code>仓库中最新的代码在本地更新一下，但是这就是导致了工作区（也就是当前编辑区）下的代码会受到干扰，因为拉下的文件也可能与工作区下的代码冲突，所以这个时候，如果我们将当前的修改放到一个区域，拉下来的代码放到另一个区域，再将这两个区域进行合并就方便多了，而暂存区就是用来存放代码的，我们可以通过<code>git add .</code>指令将工作区代码存放到暂存区，然后通过<code>git pull origin master</code>指令将<code>GIT</code>仓库中最新的版本更新到工作区，但是这样虽然达到了工作区内容是<code>GIT</code>仓库最新版，暂存区内容是我编辑的最新版的目的，但是如何进行智能的合并呢？这就涉及到了分支问题。</p><blockquote><p>默认情况下，只有一个主分支:  <code>master</code> ，我们可以通过<code>git checkout -b &#39;xxxx&#39;</code>来创建一个名为<code>xxxx</code> 的分支，然后通过 <code>git checkout xxxx</code>来进行分支切换, 通过<code>git branch</code>指令查看所有分支 ，通过<code>git merge xxxx</code>合并分支，通过<code>git branch -D xxxx</code>删除分支，值得注意的是你可以合并、删除任何分支，但是不能在当前分支下进行删除当前分支的操作。</p></blockquote></li><li><p>如果我们在<code>git pull</code>之前 创建一个分支例如<code>git checkout -b &#39;loong&#39;</code>，通过<code>git add .</code>将我的修改添加到<code>loong</code>分支的暂存区上，再切换回主分支<code>git checkout master</code> 然后在进行<code>pull pull</code>操作，  将<code>GIT</code>仓库最新版本更新到本地主分支上面，这就相当于主分支<code>master</code>下的文件和<code>git hub</code>上是一致的，而<code>loong</code>分支上是我的修改。这样就实现了我既有了网上最新的版本，分支上也有了我当前修改的版本。这个时候我们就可以将两个分支进行合并，从而获得完全体的最新版本。</p><blockquote><p>假如我们不使用分支，直接将工作区内容添加到暂存区，然后跟新本地<code>master</code>，这样虽然达到了工作区是网上最新的版本，暂存区是我的修改，但是无法达到代码合并的目的。</p></blockquote><ul><li>在主分支上通过 <code>git merge loong</code>指令将分支合并到主分支，然后通过<code>git add .</code>，<code>git commit -m&#39;提交版本名&#39;</code>, <code>git push origin mstare</code>指令将合并完成后的代码推送到<code>git hub</code>仓库<blockquote><p>如果这个时候分支名从<code>master</code>变成<code>Merging|Master</code>那就说明你的修改和<code>GIT</code>仓库上最新的版本有了冲突，你可以到编辑器内进行冲突处理，然后再<code>git push</code>这种冲突是具体到某一个文件的某一行的差异，是比较好处理的。</p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们在做团队项目时会使用GIT来进行团队分工和配合，那么正确使用GIT的流程是什么样子的呢，分支又是如何利用的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最开始我们在&lt;code&gt;git hub&lt;/code&gt;上创建一个仓库，然后在项目的setting选项中选择&lt;code&gt;Collab
      
    
    </summary>
    
    
      <category term="Git" scheme="http://longfeihouhouhou.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://longfeihouhouhou.github.io/hello-world.md/"/>
    <id>http://longfeihouhouhou.github.io/hello-world.md/</id>
    <published>2018-03-09T07:41:50.420Z</published>
    <updated>2018-03-09T07:41:50.420Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GIT的使用指南</title>
    <link href="http://longfeihouhouhou.github.io/GIT%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md/"/>
    <id>http://longfeihouhouhou.github.io/GIT的使用指南.md/</id>
    <published>2017-05-09T14:34:33.000Z</published>
    <updated>2018-03-09T14:51:10.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT-使用指南"><a href="#GIT-使用指南" class="headerlink" title="GIT 使用指南"></a>GIT 使用指南</h1><p>[toc]</p><h2 id="git-特性"><a href="#git-特性" class="headerlink" title="git 特性"></a>git 特性</h2><p>-&gt; 管理代码版本的工具（分布式git） </p><ul><li>能记住是谁提交的东西</li><li>保存每个阶段的内容（备份功能）</li><li>可以实现时空裂缝功能</li><li>GitHub 开源  多端共享 团队协作</li><li>自动合并代码，比较不同<br>-&gt; 区别集中式 svn<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2></li><li>下载git</li><li>通过鼠标右键 git bush  here 使用git 命令行</li><li>查看 git 版本<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="comment">--version</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="使用git"><a href="#使用git" class="headerlink" title="使用git"></a>使用git</h2><ul><li>界面化操作GUI ( source tree)</li><li>命令行操作c l i<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name zhufengzhufeng</span><br><span class="line">git congif --global user.email 695409705@qq.com</span><br></pre></td></tr></table></figure></li></ul><p>-&gt;告诉git 是谁提交的代码</p><h2 id="初始化git-不能嵌套使用git"><a href="#初始化git-不能嵌套使用git" class="headerlink" title="初始化git(不能嵌套使用git)"></a>初始化git(不能嵌套使用git)</h2><ul><li>以某个文件夹作为git管理的目录<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure></li></ul><p>-&gt; 会产生一个.git文件夹</p><h2 id="提交到git前-查看暂存区是否存在"><a href="#提交到git前-查看暂存区是否存在" class="headerlink" title="提交到git前 查看暂存区是否存在"></a>提交到git前 查看暂存区是否存在</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure><p>-&gt; 如果是红色便是未添加到暂存区</p><ul><li>添加到暂存区<ul><li>git add 文件名</li><li>或者 git add .   提交所有<h3 id="提交到历史区"><a href="#提交到历史区" class="headerlink" title="提交到历史区"></a>提交到历史区</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"initial"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>单纯的git commit 会进入编辑器 可以直接通过-m +”本次提交日志”来便捷提交 </p></blockquote><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  <span class="built_in">log</span></span><br></pre></td></tr></table></figure><blockquote><p>查看所提交过的文件及历史</p></blockquote><h2 id="比较三个阶段文件区别"><a href="#比较三个阶段文件区别" class="headerlink" title="比较三个阶段文件区别"></a>比较三个阶段文件区别</h2><ul><li><p>工作区和暂存区</p><pre><code><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git diff</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>比较暂存区和历史区</p><pre><code><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="comment">--cached</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>比较工作区和历史区</p><pre><code><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git diff mater</span></span><br></pre></td></tr></table></figure></code></pre></li></ul><blockquote><p>如果一样则不显示</p><ul><li>时空裂缝<ul><li>工作区回到暂存区内容<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout 文件名</span><br><span class="line"> ``` </span><br><span class="line"> - 将暂存区内容返回到上一次</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><pre><code>git reset HEAD 文件名<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>查看历史版本</span><br></pre></td></tr></table></figure>git reflog 版本号<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>回到历史版本</span><br></pre></td></tr></table></figure>git reset --hard 版本号<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 分支</span></span></span><br><span class="line">- 查看分支</span><br></pre></td></tr></table></figure></code></pre><p>git branch<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-创建分支</span></span><br></pre></td></tr></table></figure></p><p>git checkout -b 分支名<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>切换分支</span><br></pre></td></tr></table></figure></p><p>git checkout 分支名<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>创建并切换分支名</span><br></pre></td></tr></table></figure></p><p>git checkout -b dev<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>删除分支</span><br></pre></td></tr></table></figure></p><p>git branch -D 分支名  但是不能删除当前分支<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt;每个分支是没有关`enter <span class="keyword">code</span> here`系的</span><br><span class="line">- 分支合并</span><br></pre></td></tr></table></figure></p><p>git merge dev<br><code>`</code></p><h2 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h2><ul><li>pwd  打印当前路径</li><li>rm -rf  .git  (删除文件夹)</li><li>mkdir 创建目录</li><li>ls （list show 查看目录）</li><li>cd -git-pro/ (进入文件夹)</li><li>创建一个文本并在命令行编辑<ul><li>touch 文件名</li><li>vi 文件名</li><li>i 插入模式</li><li>esc + :wq 保存推出</li><li>cat 文件名 （查看文本内容） </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GIT-使用指南&quot;&gt;&lt;a href=&quot;#GIT-使用指南&quot; class=&quot;headerlink&quot; title=&quot;GIT 使用指南&quot;&gt;&lt;/a&gt;GIT 使用指南&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;git-特性&quot;&gt;&lt;a href=&quot;#git-特性&quot; cl
      
    
    </summary>
    
    
      <category term="Git" scheme="http://longfeihouhouhou.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
